{"version":3,"file":"focus-fly.umd.min.js","sources":["../utils.js","../index.js"],"sourcesContent":["/** Object.prototype.toString.call 快捷方式 */\nexport const objToStr = obj => Object.prototype.toString.call(obj);\n\n/** 参数是否是对象 */\nexport const isObj = obj => objToStr(obj) === \"[object Object]\";\n\n/** 是否为函数 */\nexport const isFun = fun => objToStr(fun) === \"[object Function]\";\n\n/** document.activeElement 的快捷方式 */\nexport const getActiveElement = () => document.activeElement;\n\n/** document.querySelector 的快捷方式 */\nexport const querySelector = str => document.querySelector(str);\n\n/** 通过字符串查找节点，或者直接返回节点 */\nexport const element = e => typeof e === \"string\" ? querySelector(e) : e;\n\n/** 滴答 */\nexport const tick = function(fn) {\n  setTimeout(fn, 0);\n};\n\n/** 是否是 input 可 select 的元素 */\nexport const isSelectableInput = function(node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n};\n\n/** 是否按下了 enter */\nexport const isEnterEvent = function(e) {\n  return e.key === \"Enter\" || e.keyCode === 13;\n};\n\n/** 按键是否是 esc */\nexport const isEscapeEvent = function (e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\n/** 按键是否是 tab */\nexport const isTabEvent = function(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\n/** 是否是向前的 tab */\nexport const isTabForward = function(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n/** 是否是向后的 tab */\nexport const isTabBackward = function(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\n\n/** 找到两个元素的最小公共祖先元素 */\nexport const findLowestCommonAncestorNode = function(x, y) {\n  if (x == null || y == null) return null;\n  if (x.contains(y)) return x;\n  if (y.contains(x)) return y;\n\n  const range = new Range();\n  range.setStartBefore(x);\n  range.setEndAfter(y);\n  if (range.collapsed) {\n     range.setStartBefore(y);\n     range.setEndAfter(x);\n  }\n  return range.commonAncestorContainer;\n};\n\n/** 从字符串中分解按键 */\nexport const getKeysFromStr = function(str) {\n  const firstMinus = str.indexOf('-');\n  const firstKey = firstMinus === -1 ? str : firstMinus === 0 ? '-' : str.slice(0, firstMinus);\n  const extraStr = str.replace(firstKey, '');\n  const keys = [firstKey];\n  const reg = /-(?:-|[^-]+)/g;\n  let res;\n  while(res = reg.exec(extraStr))\n    keys.push(res[0].slice(1));\n  let shift = false;\n  let meta = false;\n  let alt = false;\n  let ctrl = false;\n  let commonKey = null;\n  let enableKeyMap = new Map([\n    [\"Shift\", () => shift = true],\n    [\"Meta\", () => meta = true],\n    [\"Alt\", () => alt = true],\n    [\"Control\", () => ctrl = true],\n  ]);\n  for(let i = 0; i < keys.length; ++ i) {\n    const enableKey = enableKeyMap.get(keys[i]);\n    if (enableKey == null)\n      commonKey = keys[i];\n    else enableKey();\n  }\n  return {\n    shift,\n    meta,\n    alt,\n    ctrl,\n    commonKey,\n  };\n}","import { objToStr, isObj, isFun, getActiveElement, element, tick, isSelectableInput, isEnterEvent, isEscapeEvent, isTabForward, isTabBackward, findLowestCommonAncestorNode, getKeysFromStr } from \"./utils\";\n\n/** 聚焦，如果是 input，则聚焦后选中 */\nconst focus = function(e) {\n  e.focus();\n  if (isSelectableInput(e))\n    e.select();\n};\n\n/** 尝试聚焦，如果聚焦失效，则下个 setTimeout 再次聚焦 */\nconst tickFocus = function(e) {\n  if (e == null) tick(() => e && focus(e));\n  else focus(e);\n};\n\n/** 是否匹配按键 */\nconst matchKeys = function(keys, e, prevI, curI) {\n  let matched = false;\n  for (const key of keys) {\n    if (isFun(key)) {\n      matched = key(e, prevI, curI);\n    } else {\n      const { shift, meta, alt, ctrl, commonKey } = key;\n      matched = ((shift && e.shiftKey) || !(shift || e.shiftKey)) &&\n        ((meta && e.metaKey) || !(meta || e.metaKey)) &&\n        ((alt && e.altKey) || !(alt || e.altKey)) &&\n        ((ctrl && e.ctrlKey) || !(ctrl || e.ctrlKey)) &&\n        (commonKey == null || (commonKey === e.key));\n    }\n    if (matched) return matched; // true\n  }\n  return matched; // false\n};\n\n/** 转换用户输入的按键为程序可理解的按键 */\nconst convertKeys = function(keys, defaultKey) {\n  return [].concat(keys).map(k => typeof k === \"string\" ? getKeysFromStr(k) : k ?? defaultKey);\n}\n\n/** 获取根节点 */\nconst getRootNode = function(rootStr, listHead, listTail) {\n  return element(rootStr) ?? findLowestCommonAncestorNode(listHead, listTail);\n};\n\n/** 获取列表节点 */\nconst getListNodes = function(listAry) {\n  const list = listAry.map(item => element(item)).filter(item => item != null);\n  const head = list[0];\n  const tail = list.slice(-1)[0];\n  return { list, head, tail };\n}\n\n/** 获取封面节点 */\nconst getCoverNode = function(coverStr, coverIsRoot, root) {\n  return coverIsRoot ? root : element(coverStr);\n}\n\n/** 获取关键节点 */\nconst getKeyNodes = function(originRoot, originList, originCover, coverIsRoot) {\n  const { list, head, tail } = getListNodes(originList);\n  const root = getRootNode(originRoot, head, tail);\n  const cover = getCoverNode(originCover, coverIsRoot, root);\n\n  return {\n    root,\n    list, head, tail,\n    cover,\n  };\n};\n\n/** 用于处理节点属性可以传递数组的情况，用于入口和出口 */\nconst pickNodesAry = function(acc, cur) {\n  const isAryNodes = Array.isArray(cur.node);\n  const nodes = isAryNodes ? cur.node.map(n => ({\n    ...cur,\n    node: n,\n  })) : cur;\n  return acc.concat(nodes);\n};\n\n/** 获取分割的出口 */\nconst splitExits = function(exits, root) {\n  /** 生效的节点是否在根元素内部（列表中） */\n  const isInnerRoot = node => isFun(node) || (node != null && root.contains(element(node))) || node == null;\n\n  const [keyExits, clickExits, focusExits, clickExits_wild, focusExits_wild, outListExits] = exits.reduce((acc, e) => {\n    let [key, click, focus, click_wild, focus_wild, outList] = acc;\n    const includeType = type => e.type?.includes(type);\n    if (isInnerRoot(e.node)) {\n      if (includeType(\"keydown\")) key = key.concat(e);\n      if (includeType(\"click\")) click = click.concat(e);\n      if (includeType(\"focus\")) focus = focus.concat(e);\n      if (includeType(\"outlist\")) outList = outList.concat(e);\n    } else {\n      if (includeType(\"click\")) click_wild = click_wild.concat(e);\n      if (includeType(\"focus\")) focus_wild = focus_wild.concat(e);\n      if (includeType(\"outlist\")) outList = outList.concat(e);\n    }\n    return [key, click, focus, click_wild, focus_wild, outList];\n  }, new Array(6).fill([]));\n\n  const hasClickExits = clickExits.length > 0;\n  const hasFocusExits = focusExits.length > 0;\n  const hasKeyExits = keyExits.length > 0;\n  \n  return {\n    keyExits, clickExits, focusExits, hasClickExits, hasFocusExits, hasKeyExits,\n    clickExits_wild, focusExits_wild,\n    outListExits,\n  };\n}\n\n/** 获取（生成）出口 */\nconst getExits = function(exit, onEscape, enabledCover, cover, trigger, delayToBlur) {\n\n  let tempExits = [].concat(exit).filter(o => o != null)\n    .map(ele => isObj(ele) ? ele : { node: ele })\n    .map(e => ({\n      ...e,\n      preventDefault: e.preventDefault ?? true,\n      delay: e.delay ?? delayToBlur,\n      // undefined 表示用户没有主动设置\n      type: e.type === undefined ? [e.key == null ? '' : \"keydown\", e.node == null ? '' : \"click\"].filter(t => t !== '') : [].concat(e.type),\n      key: convertKeys(e.key),\n    }))\n    .reduce(pickNodesAry, []);\n  let _onEscape = isFun(onEscape) ? onEscape : onEscape === true ? tempExits[0]?.on ?? (() => {}) : onEscape;\n  /** 按下 esc 的出口 */\n  const escapeExit = isFun(_onEscape) ? {\n    node: null,\n    key: [isEscapeEvent],\n    on: _onEscape,\n    target: enabledCover ? cover : trigger,\n    type: [\"keydown\"],\n  } : null;\n  const exits = [escapeExit].concat(tempExits).filter(e => e != null);\n\n  return exits;\n};\n\n/** 延迟执行某些操作 */\nconst delayToProcess = function(delay, processor) {\n\n  const { promiseDelay, callbackDelay, commonDelay, delayRes } = getDelayType();\n  if (promiseDelay) delayRes.then(processor);\n  else if (callbackDelay) {} // 已执行完毕\n  else if (commonDelay) processor();\n\n  /** 获取聚焦或失焦时延迟的类型 */\n  function getDelayType() {\n\n    const isFunctionDelay = isFun(delay);\n    const delayRes = isFunctionDelay && delay(processor);\n    const promiseDelay = isFunctionDelay && objToStr(delayRes) === \"[object Promise]\" && typeof delayRes.then === \"function\";\n    const callbackDelay = isFunctionDelay && !promiseDelay;\n    const commonDelay = !promiseDelay && !callbackDelay; // 立即执行\n    return {\n      promiseDelay,\n      callbackDelay,\n      commonDelay,\n      delayRes,\n    };\n  }\n};\n\n/** 获取出口或者入口的目标 */\nconst getTarget = function(target, cover, list, root, enabledCover, activeIndex, defaultTarget, e) {\n  const isDefaultTarget = t => t == null || t === true;\n  // 空 target 走默认\n  if (isDefaultTarget(target))\n    return returnDefaultTarget();\n  // 函数 target 则传入节点执行\n  else if (isFun(target)) {\n    const gotTarget = target({ e, list, cover, root, last: list[activeIndex], lastI: activeIndex });\n    if (isDefaultTarget(gotTarget))\n      return returnDefaultTarget();\n    return gotTarget;\n  }\n  // 选择器字符串或者节点，则直接获取\n  else return element(target);\n\n  function returnDefaultTarget() {\n    if (enabledCover) return cover;\n    else return defaultTarget;\n  }\n};\n\n/** 保存的监听事件信息，方便监听和移除监听 */\nclass ListenersCache {\n  cache = [];\n  isEmpty = true;\n  push(node, type, handler) {\n    this.isEmpty = false;\n    this.cache.push({\n      node,\n      type,\n      handler,\n    });\n  }\n  clean() {\n    this.cache = [];\n    this.isEmpty = true;\n  }\n  addListeners() {\n    this.cache.forEach(l => l.node?.addEventListener(l.type, l.handler));\n  }\n  removeListeners() {\n    this.cache.forEach(l => l.node?.removeEventListener(l.type, l.handler));\n    this.clean();\n  }\n}\n\n/** 按键转发的缓存 */\nclass KeyForwardCache {\n  cache = new Map();\n  has(id) {\n    return this.cache.has(id);\n  }\n  push(id, node, handler) {\n    if (this.has(id)) return;\n    node.addEventListener(\"keydown\", handler);\n    this.cache.set(id, {\n      node,\n      handler,\n    })\n  }\n  remove(id) {\n    const ids = [].concat(id);\n    ids.forEach(id => this.cache.get(id).node.removeEventListener(\"keydown\", this.cache.get(id).handler));\n  }\n}\n\n/** 保存列表数据 */\nclass TabList {\n  data = [];\n  head = null;\n  tail = null;\n  prevI = -1;\n  curI = -1;\n  _prev = null;\n  _cur = null;\n  rangeBeforePrevCallback = false; // 范围模式下，当前是否在调用钩子回调（onMove、onPrev）之前\n  rangeBeforeNextCallback = false; // 范围模式下，当前是否在调用钩子回调（onMove、onNext）之前\n  get prev() {\n    return this._prev || this.data[this.prevI] || null; // _prev 可能由于 dom 未加载而为 null，为 null 则通过 prevI 取值\n  };\n  get cur() {\n    return this._cur || this.data[this.curI] || null;\n  };\n  set prev(v) {\n    this._prev = v;\n  };\n  set cur(v) {\n    this._cur = v;\n  };\n  update(list) {\n    this.data.splice(0, this.data.length);\n    Array.prototype.push.apply(this.data, list);\n    this.head = list[0];\n    this.tail = list.at(-1);\n  };\n  isEmpty() {\n    return this.data.length === 0;\n  };\n  has(i) {\n    return !!this.data[i];\n  };\n  record(cur, curI) {\n    this.recordPrev(this.cur, this.curI);\n    this.recordCur(cur, curI);\n  };\n  recordRange(cur) {\n    if (this.cur === cur || (this.cur == null && cur == null))\n      return;\n    this.record(cur, -1);\n  };\n  recordPrev(prev, prevI) {\n    this.prevI = prevI < 0 ? -1 : prevI;\n    this.prev = prev || null;\n  };\n  recordCur(cur, curI) {\n    this.curI = curI < 0 ? -1 : curI;\n    this.cur = cur || null;\n  };\n  recordSequenceByIdx(curI) {\n    const cur = this.data[curI];\n    if (this.curI === curI // this.curI 和 curI 必须不同\n      || (this.curI < 0 && curI < 0)) // curI 为 -1 后，不会再次更新新的 -1\n      return;\n    this.record(cur, curI);\n  };\n}\n\nconst focusFly = (...props) => {\n  const offset = 0 - (props[0] instanceof Array);\n  const rootNode = props[0 + offset];\n  const subNodes = props[1 + offset];\n  const options  = props[2 + offset] ?? {};\n\n  if (!(Array.isArray(subNodes) && subNodes.length > 1))\n    throw new Error(\"请至少传入一个数组，数组至少包含两个可聚焦元素，用来表示列表的头和尾。\");\n\n  const {\n    /** move: tab 序列，指定可以聚焦的元素，聚焦 list 内的元素 */\n    sequence,\n    /** move: 是否循环，设置后，尾元素的下个焦点是头元素，头元素的上个焦点是尾元素 */\n    loop,\n    /** move: 自定义前进焦点函数 */\n    next,\n    /** move: 自定义后退焦点函数 */\n    prev,\n    /** focus/blur: 触发器，如果使用 focusFly.enter 则不用设置，如果使用 entry.selector 则不用设置 */\n    trigger,\n    /** focus: 触发触发器的配置 */\n    entry,\n    /** blur: 触发退出触发器的配置 */\n    exit,\n    /** blur: 按下 esc 的行为，如果未设置，则取 exit.on */\n    onEscape,\n    /** 点击列表单项的响应，行为 */\n    onClick,\n    /** 移动的时候触发 */\n    onMove,\n    /** cover: 封面，默认情况，触发入口后首先聚焦封面，而不是子元素 */\n    cover: origin_cover,\n    /** 初始的列表中聚焦元素的序号 */\n    initialActive,\n    /** 矫正列表的焦点 */\n    correctionTarget,\n    /** 延迟挂载非触发器元素的事件，可以是一个返回 promise 的函数，可以是一个接收回调函数的函数 */\n    delayToFocus,\n    /** 延迟失焦，触发出口后等待执行 delayToBlur 完成后失焦 */\n    delayToBlur,\n    /** 每次退出列表回到入口是否移除列表事件 */\n    removeListenersEachExit = true,\n    /** 每次进入列表是否移除入口事件 */\n    removeListenersEachEnter,\n    /** 每次退出列表是否添加入口监听事件 */\n    addEntryListenersEachExit = true,\n    /** 阻止（列表移动）冒泡或捕获 */\n    stopPropagation: listStopPropagation = false,\n    /** 阻止（列表移动）默认行为 */\n    preventDefault,\n    /** 手动添加和移除监听事件，入口、列表、出口的监听事件，`removeListenersEachExit` 和 `removeListenersEachEnter` 将失效 */\n    manual,\n    /** 用于抹平 Safari 不同于其它浏览器，点击后 button 之类的元素不会被聚焦的问题 */\n    allowSafariToFocusAfterMousedown = true,\n    /** 用于内部调试 */\n    // demo = false,\n  } = options;\n\n  /** 入口们 */\n  const entries = [].concat(entry) // 转为数组\n    .filter(o => o != null) // 过滤空值\n    .map(ele => isObj(ele) ? ele : { node: ele }) // 元素转为对象，并且默认元素的值被看作对象的 node 属性\n    .map(entry => ({ // 对元素的属性进行默认处理\n      ...entry,\n      preventDefault: entry.preventDefault ?? true,\n      delay: entry.delay ?? delayToFocus,\n      type: entry.type === undefined ? [entry.key == null ? '' : \"keydown\", entry.node == null ? '' : \"click\"].filter(t => t != '') : [].concat(entry.type),\n      onExit: entry.onExit === true ? entry.on : entry.onExit, // 这个入口是开关吗\n      key: convertKeys(entry.key),\n    }))\n    .reduce(pickNodesAry, []); // 处理元素的 node 属性是数组的情况，将它分解成多个元素\n  /** 是否是空入口 */\n  const hasNoEntry = entries.length === 0;\n  /** 带切换的入口，如果 entry.onExit 有值，代表这个入口同时也是出口，也就是开关 */\n  const toggles = new Set(entries.map(e => isFun(e.onExit) ? e.node : null).filter(n => n != null).map(n => element(n)));\n  /** 默认入口，默认情况下，会从出口回到这个入口 */\n  let _trigger = element(trigger || entries[0]?.node);\n\n\n  const {\n    /** 封面节点 */\n    node: coverNode,\n    enterKey: coverEnterKey,\n    onEnter: onEnterCover,\n    exit: exitCover,\n  } = isObj(origin_cover) ? origin_cover : {};\n  /** 是否已经打开封面选项 */\n  const enabledCover = origin_cover != null && origin_cover !== false && coverNode !== false;\n  /** 封面即根元素 */\n  const coverIsRoot = enabledCover && (origin_cover === true || coverNode === true || coverNode == null);\n  /** 退出封面，封面的出口们 */\n  const exitsCover = [].concat(exitCover) // 转为数组\n    .filter(e => e != null) // 过滤空值\n    .map(e => isObj(e) ? e : { key: e }) // 元素转为对象，并且默认元素的值被看作对象的 key 属性\n    .map(e => ({ // 对元素的属性进行默认处理\n      ...e,\n      target: e.target ?? _trigger,\n      key: convertKeys(e.key),\n    }));\n  /** 是否使用默认的离开封面方法，也即 tab 和 shift-tab */\n  const isDefaultExitCover = enabledCover && exitsCover.length === 0;\n\n\n  /** 列表 */\n  const list = new TabList();\n  /** 根元素 */\n  let root = null;\n  /** 封面 */\n  let cover = null;\n\n  list.recordPrev(null, initialActive ?? -1);\n\n  const objNext = isObj(next) ? next : { key: next };\n  const {\n    key: isNext,\n    on: onNext,\n  } = {\n    ...objNext,\n    key: convertKeys(objNext.key, isTabForward)\n  };\n\n  const objPrev = isObj(prev) ? prev : { key: prev };\n  const {\n    key: isPrev,\n    on: onPrev,\n  } = {\n    ...objPrev,\n    key: convertKeys(objPrev.key, isTabBackward)\n  };\n\n  /** 禁用左上角 esc 出口 */\n  const disabledEsc = onEscape === false;\n\n  /** 取消循环则设置头和尾焦点 */\n  const isClamp = !(loop ?? true);\n\n  /** 是否打开列表序列，按照序列的顺序进行焦点导航 */\n  const enabledTabSequence = !!(next || prev || sequence); // 自定义前进或后退焦点函数，则设置 sequence 为 true\n\n  /** 移动列表，是否阻止默认行为 */\n  const listPreventDefault = preventDefault ?? enabledTabSequence;\n\n  /** 进入了列表 */\n  let trappedList = false;\n  /** 进入了封面 */\n  let trappedCover = false;\n\n  /** 是否已添加监听事件 */\n  const listListeners = new ListenersCache();\n  /** 是否已添加入口的监听事件 */\n  const entryListeners = new ListenersCache();\n  /** 按键转发，监听事件 */\n  const keyForwards = new KeyForwardCache();\n\n  if (!manual) { // 如果不是手动添加事件，则注册入口、列表相关（封面、列表、出口）的事件\n    // 入口点击事件\n    addEntryListeners();\n\n    // 如果有入口不需要延迟，则立即加载列表的监听事件\n    const hasImmediateEntry = (hasNoEntry ? [{}] : entries).some(({ delay }) => !delay);\n\n    if (hasImmediateEntry) {\n\n      const {\n        root: newRoot, list: newList, cover: newCover,\n      } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n      list.update(newList);\n      root = newRoot;\n      cover = newCover;\n\n      loadListRelatedListeners(root, list, cover);\n    }\n  }\n\n  const Return = {\n    /** 调用形式的入口 */\n    enter(entry) {\n      _trigger = _trigger || getActiveElement();\n\n      if (entry) {\n        const { on, target, delay } = entry;\n        return entryHandler({ fromInvoke: true }, on, target, delay);\n      } else {\n        for (let i = 0; i < entries.length; ++ i) {\n          const { on, type, node, target, delay } = entries[i];\n          const invokeType = \"invoke\";\n\n          if (type?.some(type => type == null || type === false || type === invokeType) || node == null) {\n            return entryHandler({ fromInvoke: true }, on, target, delay);\n          }\n        }\n        return entryHandler({ fromInvoke: true });\n      }\n    },\n    /** 调用形式的出口 */\n    exit(tempExit) {\n\n      const {\n        list: newList,\n        cover,\n        root,\n      } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n\n      if (tempExit) {\n        const { on, target: originTarget } = tempExit;\n        const target = element(originTarget);\n        return toExit(target, on);\n      } else {\n        const exits = getExits(exit, onEscape, enabledCover, cover, _trigger, delayToBlur);\n        for (let i = 0; i < exits.length; ++ i) {\n          const { on, type, target } = exits[i];\n          const invokeType = \"invoke\";\n  \n          if (type?.some(type => type == null || type === false || type === invokeType)) {\n            return toExit(target, on);\n          }\n        }\n      }\n\n      function toExit(target, on) {\n\n        if (list.isEmpty()) list.update(newList);\n\n        return exitHandler({ fromInvoke: true }, on, target, false, cover, list.data, root);\n      }\n    },\n    /** 移除所有的监听事件 */\n    removeListeners() {\n      listListeners.removeListeners();\n      entryListeners.removeListeners();\n    },\n    /** 移除列表相关的事件 */\n    removeListRelatedListeners() {\n      listListeners.removeListeners();\n    },\n    /** 移除入口事件 */\n    removeEntryListeners() {\n      entryListeners.removeListeners();\n    },\n    /** 添加入口的监听事件 */\n    addEntryListeners() {\n      addEntryListeners();\n    },\n    /** 添加列表相关（封面、列表、出口）的监听事件 */\n    addListRelatedListeners() {\n\n      const {\n        root,\n        list: newList,\n        cover,\n      } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n      if (list.isEmpty()) list.update(newList);\n\n      loadListRelatedListeners(root, list, cover);\n    },\n    /** 添加转发 */\n    addForward(id, forward) {\n      let opts = null;\n      if (isFun(forward)) {\n        const {\n          root,\n          list: listData, head, tail,\n          cover,\n        } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n\n        opts = forward({ root, list: listData, head, tail, cover, curI: list.curI, prevI: list.prevI });\n      }\n      else opts = forward;\n\n      const { node: origin_node, on, key: origin_key, target: origin_target } = opts;\n      const node = element(origin_node);\n      const target = element(origin_target);\n      const keys = convertKeys(origin_key);\n      keyForwards.push(id, node, e => {\n        if (matchKeys(keys, e, list.prevI, list.curI)) {\n          e.preventDefault();\n          on?.();\n          tickFocus(target);\n        }\n      });\n    },\n    /** 移除转发 */\n    removeForward(id) {\n      keyForwards.remove(id);\n    },\n    /** 更新列表 */\n    updateList(newList) {\n      const _newList = newList.map(item => element(item)).filter(item => item != null);\n      list.update(_newList);\n    },\n    /** 当前聚焦的列表单项序号 */\n    i(newI) {\n      if (list.has(newI) && trappedList) {\n        list.recordSequenceByIdx(newI);\n        const { prev, prevI, cur, curI } = list;\n        onMove?.({ e: { fromI: true }, prev, prevI, cur, curI });\n        focus(subNodes[curI]);\n        return newI;\n      }\n      else return list.curI < 0 ? list.prevI : list.curI;\n    },\n  };\n\n  return Return;\n\n  /** 入口 handler */\n  function entryHandler(e, onEnter, target, delay, preventDefault, stopPropagation) {\n\n    // 如果已经在列表或者封面，则不再触发入口；出口不需要该操作，因为不存在从出口退出到出口的子元素的情况，相反，存在入口进入到入口子元素的情况。\n    if (trappedCover || trappedList) return;\n\n    preventDefault && e.preventDefault?.();\n    stopPropagation && e.stopPropagation?.();\n\n    Promise.resolve(onEnter?.(e)).then(_ => {\n      delayToProcess(delay, findNodesToLoadListenersAndFocus);\n    });\n\n    /** 寻找节点，加载事件监听器，聚焦 subNodes 或 coverNode */\n    function findNodesToLoadListenersAndFocus() {\n\n      if (list.isEmpty()) {\n        const { list: newList } = getListNodes(subNodes);\n        list.update(newList);\n      }\n\n      if (root == null)\n        root = getRootNode(rootNode, list.head, list.tail);\n\n      if (cover == null && enabledCover)\n        cover = getCoverNode(coverNode, coverIsRoot, root);\n\n      if (!manual)\n        loadListRelatedListeners(root, list, cover);\n      if (target !== false)\n        focusTarget(cover, list, root);\n    }\n    \n    function focusTarget(cover, listInfo, rootNode) {\n      const list = listInfo.data;\n      const { prev, head, curI } = listInfo;\n      const defaultTarget = prev || head;\n      const gotTarget = getTarget(target, cover, list, rootNode, enabledCover, curI, defaultTarget, e);\n      if (enabledTabSequence) { // 序列模式\n        const targetIdx = list.indexOf(gotTarget);\n        if (targetIdx > -1) {\n          listInfo.recordSequenceByIdx(targetIdx); // 只有在聚焦列表元素时才设置，否则会破坏原有 curI\n          const { cur, curI } = listInfo;\n          onMove?.({ e, prev: null, cur, prevI: -1, curI });\n          trappedList = true;\n        }\n      } else { // 范围模式\n        if (rootNode.contains(gotTarget) && gotTarget !== cover) {\n          listInfo.recordRange(gotTarget);\n          const { cur, curI } = listInfo;\n          onMove?.({ e, prev: null, cur, prevI: -1, curI });\n          trappedList = true;\n        }\n      }\n      if (enabledCover && (gotTarget === cover || trappedList === true)) trappedCover = true;\n      tickFocus(gotTarget);\n    }\n  }\n\n  /** 出口 handler */\n  function exitHandler(e, on, target, delay, cover, listData, root, ef, preventDefault, stopPropagation) {\n\n    if (!trappedList || \n      !(isFun(ef) ? ef({ e, prev: list.prev, cur: list.cur, prevI: list.prevI, curI: list.curI }) : true))\n      return false;\n\n    preventDefault && e.preventDefault?.(); // 阻止默认行为，例如 tab 到下一个元素，例如 entry button 触发 click 事件\n    stopPropagation && e.stopPropagation?.();\n\n    if (enabledTabSequence) list.recordSequenceByIdx(-1);\n    else list.recordRange(null);\n\n    trappedList = false;\n\n    const gotTarget = getTarget(target, cover, listData, root, enabledCover, list.curI, _trigger, e);\n\n    if (gotTarget) return exitListWithTarget();\n    else return exitListWithoutTarget();\n\n    /** 退出列表，有 target */\n    function exitListWithTarget() {\n\n      Promise.resolve(on?.(e)).then(_ => {\n        delayToProcess(delay, focusThenRemoveListeners);\n      });\n\n      function focusThenRemoveListeners() {\n        if (!manual) {\n          if (gotTarget !== cover)\n            removeListRelatedListeners();\n          if (addEntryListenersEachExit)\n            addEntryListeners();\n        }\n        onMove?.({ e, prev: list.prev, cur: null, prevI: list.prevI, curI: -1 });\n        focus(gotTarget);\n      }\n    }\n\n    /** 退出列表，无 target */\n    function exitListWithoutTarget() {\n\n      Promise.resolve(on?.(e)).then(_ => {\n\n        if (gotTarget === false) { // 如果显式设为 false，则直接退出，不聚焦，会在一个列表退出另一个列表移动的场景使用\n\n          const removeListenersWithoutFocus = focusThenRemoveListeners();\n          removeListenersWithoutFocus();\n          return ;\n        }\n\n        const focusTriggerThenRemoveListeners = focusThenRemoveListeners(_trigger);\n        delayToProcess(delay, focusTriggerThenRemoveListeners);\n      });\n\n      function focusThenRemoveListeners(focusTarget) {\n        return _ => {\n          if (!manual) {\n            removeListRelatedListeners();\n            if (addEntryListenersEachExit)\n              addEntryListeners();\n          }\n          onMove?.({ e, prev: list.prev, cur: null, prevI: list.prevI, curI: -1 });\n          focusTarget && focus(focusTarget);\n        }\n      }\n    }\n  }\n\n  /** 生成事件行为，添加事件监听器 */\n  function loadListRelatedListeners(root, listInfo, cover) {\n\n    const list = listInfo.data;\n    const head = listInfo.head;\n    const tail = listInfo.tail;\n\n    if (!listListeners.isEmpty) return ; // 列表的监听事件没有移除之前，不需要再次添加列表监听事件\n\n    if (root == null)\n      throw new Error(`没有找到元素 ${rootNode}，您可以尝试 delayToFocus 选项，等待元素 ${rootNode} 渲染完毕后进行聚焦。`);\n    if (head == null || tail == null)\n      throw new Error(\"至少需要包含两个可以聚焦的元素，如果元素需要等待渲染，您可以尝试 delayToFocus 选项。\");\n\n    // 添加除 trigger 以外其它和焦点相关的事件监听器\n    addListRelatedListeners();\n\n    /** 添加焦点需要的事件监听器 */\n    function addListRelatedListeners() {\n\n      /** 是否是来自默认封面出口的聚焦 */\n      let focusFromDefaultExitCover = false;\n\n      const useActiveIndex = () => [listInfo.curI, listInfo.recordSequenceByIdx.bind(listInfo)];\n\n      const isTrappedList = () => hasNoEntry ? true : trappedList;\n\n      // 在焦点循环中触发聚焦\n      const keyListMoveHandler = enabledTabSequence ? focusNextListItemBySequence : focusNextListItemByRange;\n\n      /** 出口们，列表的出口们，list 的出口们 */\n      const exits = getExits(exit, onEscape, enabledCover, cover, _trigger, delayToBlur);\n      const {\n        keyExits, clickExits, focusExits, hasClickExits, hasFocusExits, hasKeyExits,\n        clickExits_wild, focusExits_wild,\n        outListExits,\n      } = splitExits(exits, root);\n\n      /** 非跟节点内的，是根节点之外的出口 */\n      const clickListExitHandlers_wild = clickExits_wild.map(exit => [element(exit?.node), clickListExitHandler_wild(exit)]);\n      const focusListExitHandlers_wild = focusExits_wild.map(exit => [element(exit?.node), focusListExitHandler_wild(exit)]);\n\n      listListeners.push(root, \"focusin\", focusTrapListHandler);\n\n      listListeners.push(root, \"focusout\", blurTrapListHandler);\n\n      if (!root.contains(cover) && cover != null) {\n\n        listListeners.push(cover, \"focus\", focusTrapCoverHandler);\n\n        listListeners.push(cover, \"blur\", blurTrapCoverHandler);\n      }\n\n      listListeners.push(root, \"keydown\", e => {\n        let exited = false;\n        // 列表键盘出口\n        if (hasKeyExits)\n          exited = keyListExitHandler(e);\n        // 列表中移动，监听移动的键盘事件，例如 tab 或其它自定义组合键\n        if (!exited) // 退出的优先级高于列表移动\n          keyListMoveHandler(e);\n      });\n\n      listListeners.push(root, \"click\", e => {\n        // 点击聚焦列表单项，只在手动列表时监听点击，因为自动模式不需要记录 list.curI\n        clickListItemHandler(e);\n        // 列表点击出口\n        hasClickExits && clickListExitHandler(e);\n      });\n\n      // 由于 click 事件在 focus 之后，这里用来判断是否通过点击进入列表，用于纠错未知进入列表的焦点定位\n      listListeners.push(root, \"mousedown\", mousedownListItemHandler);\n\n      if (hasFocusExits) {\n        // 列表聚焦出口\n        listListeners.push(root, \"focusin\", focusListExitHandler);\n      }\n\n      // 非列表内的出口\n      focusListExitHandlers_wild.forEach(([node, handler]) => {\n        listListeners.push(node, \"focus\", handler);\n      });\n      clickListExitHandlers_wild.forEach(([node, handler]) => {\n        listListeners.push(node, \"click\", handler);\n      });\n\n      if (cover != null) {\n        // 封面的事件\n        listListeners.push(cover, \"keydown\", keyCoverHandler);\n      }\n\n\n      /** 是否触发了开关的 mousedown，如果是，则代表当前触发的是开关，需要忽略跳过列表的 blur 事件 */\n      let triggeredToggleMousedown = false;\n\n      // 若存在 outlist 类型，则为入口添加 mousedown，用于入口是开关的情况\n      if (outListExits) {\n        toggles.forEach(toggle => {\n          listListeners.push(toggle, \"mousedown\", _ => triggeredToggleMousedown = true);\n        });\n      }\n\n      // flush\n      listListeners.addListeners();\n\n\n\n      let isMouseDown = false;\n      /** 标记是否从封面进入列表，用于防止纠正列表焦点的误判，用于野生封面 */\n      let isEnterFromCover = false;\n\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n       |          LIST HANDLERS          |\n       +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n\n      function focusTrapListHandler(e) {\n\n        /** 当前焦点 */\n        const target = e.target;\n        /** 前一个焦点 */\n        const relatedTarget = e.relatedTarget;\n\n        // 默认封面退出\n        if (focusFromDefaultExitCover) {\n          focusFromDefaultExitCover = false;\n          return;\n        }\n\n        // 进入封面（封面在列表中）\n        if (enabledCover && target === cover) { // TODO: 保留确认，或是否需要添加 `&& trappedList` 条件\n          trappedCover = true;\n          return ;\n        }\n\n        // 纠正进入封面，从外部进入列表，如果没有通过封面，则重新聚焦封面\n        if (enabledCover && isMouseDown === false && trappedCover === false) {\n          tickFocus(cover);\n          return ;\n        }\n\n        // 调用范围模式下的 onPrev、onNext、onMove，此时焦点正在列表内移动\n        if (listInfo.rangeBeforePrevCallback || listInfo.rangeBeforeNextCallback) {\n          listInfo.recordRange(target);\n          listInfo.rangeBeforePrevCallback = false;\n          listInfo.rangeBeforeNextCallback = false;\n          const { cur, prev } = listInfo;\n          (listInfo.rangeBeforePrevCallback ? onNext : onPrev)?.({ e, prev, cur, prevI: -1, curI: -1 });\n          onMove?.({ e, prev, cur, prevI: -1, curI: -1 });\n          return ;\n        }\n\n        // 纠正外部聚焦进来的焦点。如果是内部的聚焦，无需纠正，防止嵌套情况的循环问题\n        if (correctionTarget !== false &&\n          trappedList === false &&\n          isMouseDown === false &&\n          (relatedTarget == null || // 上一个焦点为空\n            !root.contains(relatedTarget))) // 上一个焦点在根节点 root 以外的区域\n        {\n          const defaultLast = listInfo.prev || listInfo.head;\n          const originGotCorrectionTarget = correctionTarget?.({ list, cover, root, last: listInfo.prev, lastI: listInfo.prevI, e }) ?? defaultLast;\n          const gotCorrectionTarget = element(originGotCorrectionTarget);\n\n          onMoveTargetFromOuter(gotCorrectionTarget);\n          tickFocus(gotCorrectionTarget);\n        }\n\n        // 关闭焦点纠正，同时从外部进来了焦点\n        if (correctionTarget === false &&\n          trappedList === false &&\n          isMouseDown === false &&\n          (relatedTarget == null || !root.contains(relatedTarget)))\n          onMoveTargetFromOuter(target)\n\n        /** 矫正时的 onMove 调用 */\n        function onMoveTargetFromOuter(target) {\n          if (enabledTabSequence) { // 序列模式\n            const targetIndex = list.findIndex(item => item === target);\n            if (targetIndex > -1) {\n              listInfo.recordSequenceByIdx(targetIndex);\n              onMove?.({ e, prev: null, cur: listInfo.cur, prevI: -1, curI: listInfo.curI });\n              trappedList = true; // 在下一次 触发 focusin 调用 focusTrapListHandler 之前，设为 true。通过 api 调用的 focus，触发的 focusin 事件会被“同步”调用\n            }\n          } else { // 范围模式\n            listInfo.recordRange(target);\n            onMove?.({ e, prev: null, cur: listInfo.cur, prevI: -1, curI: listInfo.curI });\n            trappedList = true; // 在下一次 触发 focusin 调用 focusTrapListHandler 之前，设为 true。通过 api 调用的 focus，触发的 focusin 事件会被“同步”调用\n          }\n        }\n      }\n\n      function blurTrapListHandler(e) {\n        // 用于保护可切换的入口（开关，同时作为出口的入口）能够被触发；也可用 relatedTarget 判断，但 relatedTarget 不兼容 Safari（23.09.08）\n        if (triggeredToggleMousedown)\n          return triggeredToggleMousedown = false; // mousedown 一定优先 blur 触发，如果触发了 mousedown，则代表当前触发的是开关\n\n        tick(() => { // 延迟后获取下一次聚焦的元素，否则当前聚焦元素是 body\n\n          const active = getActiveElement();\n          const isOutRootNode = !root.contains(active);\n          const isActiveCover = active === cover;\n\n          // 从封面退出\n          if (e.target === cover && isOutRootNode) {\n            trappedCover = false; // 退出封面\n            return;\n          }\n\n          let isOutList = null;\n          if (isActiveCover || isOutRootNode) {\n            isOutList = outListExitHandler(e);\n            if (enabledTabSequence) listInfo.recordSequenceByIdx(-1);\n            else listInfo.recordRange(null);\n          }\n          if (isOutList === false) return; // 不符合 outlist 退出列表的条件\n\n          if (isActiveCover) { // 聚焦在封面\n            trappedList = false;\n          } else if (isOutRootNode) { // 聚焦在非封面、非列表的区域\n            trappedList = false;\n            trappedCover = false;\n          }\n        });\n      }\n\n      function mousedownListItemHandler(e) {\n        isMouseDown = true;\n        tick(() => isMouseDown = false); // mousedown 没有出口，只能使用定时器，isMouseDown 主要在两个 focus 事件中使用，当触发 focus 时，此定时器还未执行，以此保证正确性\n\n        let targetItem;\n        if (!enabledTabSequence || // 未打开 sequence 属性 或者\n          (enabledTabSequence && // 已打开 sequence 属性 并且\n            (targetItem = list.find(item => item.contains(e.target))) // 点击的目标是列表中的元素\n          )\n        ) {\n          trappedList = true;\n          if (enabledCover) trappedCover = true;\n          // 兼容 Safari（桌面端），具体问题查看：https://github.com/wswmsword/web-experiences/tree/main/browser/safari-button-focus\n          if (allowSafariToFocusAfterMousedown && targetItem && window.safari !== undefined) {\n            focus(targetItem); // Safari 不会聚焦按钮元素，这里强制使用 api 聚焦\n            e.preventDefault(); // 阻止默认行为可以避免 targetItem 失焦\n          }\n        }\n      }\n\n      /** 点击聚焦列表某一单项 */\n      function clickListItemHandler(e) {\n\n        const target = e.target;\n\n        if (enabledTabSequence) { // 序列模式\n\n          const targetIndex = list.findIndex(item => item.contains(target));\n          if (targetIndex > -1) {\n            const { prev: prevBeforeRecord, prevI: prevIBeforeRecord, curI: curIBeforeRecord } = listInfo;\n            listInfo.recordSequenceByIdx(targetIndex);\n  \n            let { prev, prevI, cur, curI } = listInfo;\n            if (curIBeforeRecord < 0) { // 从外部进入\n              if (prevIBeforeRecord !== targetIndex) { // 上一次进入 和 本次进入 的元素不同\n                prev = prevBeforeRecord;\n                prevI = prevIBeforeRecord;\n              }\n            }\n  \n            onClick?.({ e, prev, cur, prevI, curI });\n            if (curIBeforeRecord !== curI) // 从外部进入 或者 列表内的移动\n              onMove?.({ e, prev, cur, prevI, curI });\n          }\n        } else { // 范围模式\n\n          const { prev: prevBeforeRecord, cur: curBeforeRecord } = listInfo;\n          listInfo.recordRange(target);\n\n          let { prev, cur } = listInfo;\n          if (curBeforeRecord == null) { // 外部进入\n            if (prevBeforeRecord !== target) {\n              prev = prevBeforeRecord;\n            }\n          }\n\n          onClick?.({ e, prev, cur, prevI: -1, curI: -1 });\n          if (curBeforeRecord !== cur) // 从外部进入 或者 列表内的移动\n            onMove?.({ e, prev, cur, prevI: -1, curI: -1 });\n        }\n      }\n\n      /** 手动聚焦下一个元素 */\n      function focusNextListItemBySequence(e) {\n        if (e.target === cover) return;\n        if (!isTrappedList()) return;\n\n        const [index_, setIndex] = useActiveIndex();\n        const index = Math.max(0, index_);\n        const itemsLen = list.length;\n        let focused = false;\n\n        if (matchKeys(isNext, e, listInfo.prevI, listInfo.curI)) {\n          const increasedI = index + 1;\n          let nextI = isClamp ? Math.min(itemsLen - 1, increasedI) : increasedI;\n          nextI %= itemsLen;\n          onNext?.({ e, prev: list[index], cur: list[nextI], prevI: index, curI: nextI });\n          onMove?.({ e, prev: list[index], cur: list[nextI], prevI: index, curI: nextI });\n          setIndex(nextI);\n          focus(list[nextI]);\n          focused = true;\n        }\n        else if (matchKeys(isPrev, e, listInfo.prevI, listInfo.curI)) {\n          const decreasedI = index - 1;\n          let nextI = isClamp ? Math.max(0, decreasedI) : decreasedI;\n          nextI = (nextI + itemsLen) % itemsLen;\n          onPrev?.({ e, prev: list[index], cur: list[nextI], prevI: index, curI: nextI });\n          onMove?.({ e, prev: list[index], cur: list[nextI], prevI: index, curI: nextI });\n          setIndex(nextI);\n          focus(list[nextI]);\n          focused = true;\n        }\n\n        // 如果按下了 Tab，则阻止默认行为（聚焦下一个元素），无需阻止事件传播\n        (e.key === \"Tab\" || focused) && listPreventDefault && e.preventDefault();\n        focused && listStopPropagation && e.stopPropagation();\n      };\n\n      /** 按下 tab，以浏览器的行为聚焦下个元素 */\n      function focusNextListItemByRange(e) {\n        const head = list[0];\n        const tail = list.at(-1);\n        const current = e.target;\n        if (current === cover) return;\n        if (!isTrappedList()) return;\n\n        let needToPreventDefault = false;\n        let focused = false;\n        if (isTabForward(e)) {\n          listInfo.recordRange(current);\n          listInfo.rangeBeforeNextCallback = true;\n          if (current === tail) {\n            needToPreventDefault = true;\n            if (!isClamp) focus(head);\n          }\n          if (current === root) {\n            needToPreventDefault = true;\n            focus(head);\n          }\n          focused = true;\n        }\n        else if (isTabBackward(e)) {\n          listInfo.recordRange(current);\n          listInfo.rangeBeforePrevCallback = true;\n          if (current === head) {\n            needToPreventDefault = true;\n            if (!isClamp) focus(tail);\n          }\n          if (current === root) {\n            needToPreventDefault = true;\n            focus(tail);\n          }\n          focused = true;\n        }\n\n        if (needToPreventDefault || (focused && listPreventDefault)) e.preventDefault();\n        if (focused && listStopPropagation) e.stopPropagation();\n      };\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n      |         COVER HANDLERS          |\n      +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n\n      function focusTrapCoverHandler() { trappedCover = true; } // 捕获点击封面的情况\n\n      function blurTrapCoverHandler() { // 捕获点击空白区域的情况\n        if (isEnterFromCover) // 用于防止纠正列表焦点的误判，如果是进入列表，则 trappedCover 还应是 true\n          isEnterFromCover = false;\n        else\n          trappedCover = false;\n      }\n\n      /** 封面的键盘事件响应 */\n      function keyCoverHandler(e) {\n        if (e.target !== cover) return;\n        if (!(trappedCover && !trappedList)) return; // 继续执行，必须满足焦点在封面上，且不在列表中\n\n        // 入口（封面），从封面进入列表\n        if((coverEnterKey ?? isEnterEvent)(e) && !trappedList) {\n          e.preventDefault();\n          isEnterFromCover = true;\n          trappedList = true;\n          onEnterCover?.(e);\n          if (enabledTabSequence) {\n            listInfo.recordSequenceByIdx(Math.max(0, listInfo.prevI));\n            focus(listInfo.cur);\n            onMove?.({ e, prev: null, cur: listInfo.cur, prevI: -1, curI: listInfo.curI });\n          } else {\n            listInfo.recordRange(listInfo.prev == null ? listInfo.head : listInfo.prev);\n            focus(listInfo.cur);\n            onMove?.({ e, prev: null, cur: listInfo.cur, prevI: -1, curI: -1 });\n          }\n          return;\n        }\n\n        // 出口（封面），从封面回到入口\n        for (let i = 0; i < exitsCover.length; ++ i) {\n          const { key, on, target: origin } = exitsCover[i];\n          const target = element(origin);\n          if (matchKeys(key, e, listInfo.prevI, listInfo.curI)) {\n            exitCoverHandler(e, on, target);\n            return;\n          }\n        }\n\n        // 默认出口，默认行为，默认的行为的场景是包含子元素的长列表\n        if (isDefaultExitCover &&\n          isTabForward(e)) { // 虽然也是离开列表，但是这里不移除监听事件，因为移除后就不能再次进入封面\n          focusFromDefaultExitCover = true;\n          focus(tail);\n          return;\n        }\n\n        /** 退出封面焦点的行为 */\n        function exitCoverHandler(e, onExit, target) {\n          onExit?.(e);\n          target && focus(target);\n          removeListRelatedListeners();\n        }\n      }\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n      |            + START +            |\n      |          EXIT HANDLERS          |\n      +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n\n      function outListExitHandler(e) {\n        for (let i = 0; i < outListExits.length; ++ i) {\n          const { on, target: origin_target, delay, preventDefault, stopPropagation } = outListExits[i];\n          const target = element(origin_target);\n          return exitHandler(e, on, target, delay, cover, list, root, outListExits[i].if, preventDefault, stopPropagation);\n        }\n      }\n\n      function exitHandlerWithCondition(e, exit, condition) {\n        const { node: origin_node, on, target: origin_target, delay, preventDefault, stopPropagation } = exit;\n        const { data: list, head, tail } = listInfo;\n        const stringOrNode = isFun(origin_node) ? origin_node({ list, head, tail }) : origin_node;\n        const node = element(stringOrNode);\n        const target = element(origin_target);\n\n        if (condition(e, node, exit.key)) // 未设置点击目标\n          return false;\n        const res = exitHandler(e, on, target, delay, cover, list, root, exit.if, preventDefault, stopPropagation);\n        return res !== false;\n      }\n\n      function clickExitHandler(e, exit) {\n\n        const cantClick = (e, node) => (node != null && !node.contains(e.target)) || node == null; // 点击目标不匹配 或者 未设置点击目标\n        return exitHandlerWithCondition(e, exit, cantClick);\n      }\n\n      /** 点击列表的出口 */\n      function clickListExitHandler(e) {\n        for (let i = 0; i < clickExits.length; ++ i) {\n          const isOK = clickExitHandler(e, clickExits[i]);\n          if (isOK) break; // 只生效第一个满足条件的出口\n        }\n      }\n\n      function focusExitHandler(e, exit) {\n\n        const cantFocus = (e, node) => (node != null && e.target !== node) || node == null; // 聚焦目标不匹配 或者 未设置点击目标\n        return exitHandlerWithCondition(e, exit, cantFocus);\n      }\n\n      /** 聚焦列表一个单项而退出 */\n      function focusListExitHandler(e) {\n\n        for (let i = 0; i < focusExits.length; ++ i) {\n          const isOK = focusExitHandler(e, focusExits[i])\n          if (isOK) break;\n        }\n      }\n\n      function keyExitHandler(e, exit) {\n\n        const cantKey = (e, node, key) => (node != null && e.target !== node) || !(matchKeys(key, e, listInfo.prevI, listInfo.curI)); // 聚焦目标不匹配 或者 未设置点击目标\n        return exitHandlerWithCondition(e, exit, cantKey);\n      }\n\n      /** 触发键盘退出列表，退出列表焦点 */\n      function keyListExitHandler(e) {\n        if (e.target === cover) return; // 被封面触发直接返回\n\n        if (disabledEsc && isEscapeEvent(e)) return;\n\n        for (let i = 0; i < keyExits.length; ++ i) {\n          const isOK = keyExitHandler(e, keyExits[i]);\n          if (isOK) return true;\n        }\n      }\n\n      function clickListExitHandler_wild(exit) {\n        return function(e) { clickExitHandler(e, exit); }\n      }\n\n      function focusListExitHandler_wild(exit) {\n        return function(e) { focusExitHandler(e, exit); }\n      }\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n      |             - END -             |\n      |          EXIT HANDLERS          |\n      +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n    };\n  }\n\n  /** 添加入口事件 */\n  function addEntryListeners() {\n\n    if (!entryListeners.isEmpty) return;\n\n    for (let i = 0; i < entries.length; ++ i) {\n      const entry = entries[i];\n      const { node: origin, on, key, type, target, delay, onExit, preventDefault, stopPropagation } = entry;\n      const ef = entry.if;\n      const types = [].concat(type);\n      const allTypes = [\"keydown\", \"focus\", \"click\"];\n      const node = element(origin);\n\n      types.forEach(type => {\n        if (node && allTypes.includes(type)) {\n\n          /** 是否是键盘事件 */\n          const isKey = type === \"keydown\";\n          /** 如果是键盘事件，则判断键位是否匹配，如果是非键盘事件，则直接返回 true */\n          const ifKey = isKey ? e => matchKeys(key, e, list.prevI, list.curI) : _ => true;\n          entryListeners.push(node, type, toggleHandler(ifKey)); // 保存事件信息\n        }\n      });\n      \n      function toggleHandler(ifKey) {\n        return e => {\n          if (\n            (isFun(ef)\n              ? ef({ e, prev: list.prev, cur: list.cur, prevI: list.prevI, curI: list.curI })\n              : true) &&\n            ifKey(e))\n            toggleEntryAndExit(e);\n        }\n      }\n\n      function toggleEntryAndExit(e) {\n\n        if (trappedList) {\n          if (isFun(onExit)) { // 若存在 onExit，则表示该入口同时是出口，是开关\n            const { list, cover, root } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n            exitHandler(e, onExit, target, false, cover, list, root, null, preventDefault, stopPropagation);\n          }\n        }\n        else {\n          entryHandler(e, on, target, delay, preventDefault, stopPropagation);\n          if (removeListenersEachEnter && !manual)\n            entryListeners.removeListeners();\n        }\n      }\n    }\n\n    // flush\n    entryListeners.addListeners();\n  }\n\n  /** 移除监听事件 */\n  function removeListRelatedListeners() {\n\n    // 如果是默认的，没有定义出口的封面，则不移除事件\n    if (isDefaultExitCover) return;\n\n    if (removeListenersEachExit && !manual) {\n      listListeners.removeListeners();\n    }\n  }\n};\n\nexport default focusFly;"],"names":["objToStr","obj","Object","prototype","toString","call","isObj","isFun","fun","getActiveElement","document","activeElement","element","e","str","querySelector","tick","fn","setTimeout","isEnterEvent","key","keyCode","isEscapeEvent","isTabEvent","isTabForward","shiftKey","isTabBackward","focus","node","tagName","toLowerCase","select","tickFocus","matchKeys","keys","prevI","curI","_step","matched","_iterator","_createForOfIteratorHelperLoose","done","value","shift","meta","alt","ctrl","commonKey","metaKey","altKey","ctrlKey","convertKeys","defaultKey","concat","map","k","res","firstMinus","indexOf","firstKey","slice","extraStr","replace","reg","exec","push","enableKeyMap","Map","i","length","enableKey","get","getKeysFromStr","getRootNode","rootStr","listHead","listTail","_element","x","y","contains","range","Range","setStartBefore","setEndAfter","collapsed","commonAncestorContainer","findLowestCommonAncestorNode","getListNodes","listAry","list","item","filter","head","tail","getCoverNode","coverStr","coverIsRoot","root","getKeyNodes","originRoot","originList","originCover","_getListNodes","cover","pickNodesAry","acc","cur","nodes","Array","isArray","n","_extends","splitExits","exits","_exits$reduce","reduce","click","click_wild","focus_wild","outList","includeType","type","_e$type","includes","fill","keyExits","clickExits","focusExits","clickExits_wild","focusExits_wild","outListExits","hasClickExits","hasFocusExits","hasKeyExits","getExits","exit","onEscape","enabledCover","trigger","delayToBlur","_tempExits$0$on","_tempExits$","tempExits","o","ele","_e$preventDefault","_e$delay","preventDefault","delay","undefined","t","_onEscape","on","target","delayToProcess","processor","_getDelayType","isFunctionDelay","delayRes","promiseDelay","then","callbackDelay","commonDelay","getDelayType","getTarget","activeIndex","defaultTarget","isDefaultTarget","returnDefaultTarget","gotTarget","last","lastI","ListenersCache","this","cache","isEmpty","_proto","handler","clean","addListeners","forEach","l","_l$node","addEventListener","removeListeners","_l$node2","removeEventListener","KeyForwardCache","_proto2","has","id","set","remove","_this","TabList","data","_prev","_cur","rangeBeforePrevCallback","rangeBeforeNextCallback","_proto3","update","splice","apply","at","record","recordPrev","recordCur","recordRange","prev","recordSequenceByIdx","v","_ref","_entries$","offset","arguments","rootNode","subNodes","options","Error","sequence","loop","next","entry","onClick","onMove","origin_cover","initialActive","correctionTarget","delayToFocus","_options$removeListen","removeListenersEachExit","removeListenersEachEnter","_options$addEntryList","addEntryListenersEachExit","_options$stopPropagat","stopPropagation","listStopPropagation","manual","_options$allowSafariT","allowSafariToFocusAfterMousedown","entries","_entry$preventDefault","_entry$delay","onExit","hasNoEntry","toggles","Set","_trigger","_ref2","coverNode","coverEnterKey","enterKey","onEnterCover","onEnter","exitCover","exitsCover","_e$target","isDefaultExitCover","objNext","_objNext$key","isNext","onNext","objPrev","_objPrev$key","isPrev","onPrev","disabledEsc","isClamp","enabledTabSequence","listPreventDefault","trappedList","trappedCover","listListeners","entryListeners","keyForwards","addEntryListeners","some","_ref3","_getKeyNodes","newRoot","newList","newCover","loadListRelatedListeners","Return","enter","entryHandler","fromInvoke","_loop","_entries$i","_ret","tempExit","_getKeyNodes2","originTarget","toExit","_loop2","_exits$i","_ret2","exitHandler","removeListRelatedListeners","removeEntryListeners","addListRelatedListeners","_getKeyNodes3","addForward","forward","opts","_getKeyNodes4","_opts","origin_node","origin_key","origin_target","removeForward","updateList","_newList","newI","fromI","_e$preventDefault2","_e$stopPropagation","findNodesToLoadListenersAndFocus","listInfo","targetIdx","focusTarget","Promise","resolve","_","listData","ef","_e$preventDefault3","_e$stopPropagation2","focusThenRemoveListeners","exitListWithTarget","focusTriggerThenRemoveListeners","removeListenersWithoutFocus","exitListWithoutTarget","focusFromDefaultExitCover","isTrappedList","keyListMoveHandler","_useActiveIndex","bind","index_","setIndex","index","Math","max","itemsLen","focused","increasedI","nextI","min","decreasedI","current","needToPreventDefault","_splitExits","clickListExitHandlers_wild","clickListExitHandler_wild","focusListExitHandlers_wild","focusListExitHandler_wild","relatedTarget","isMouseDown","_ref6","_correctionTarget","defaultLast","originGotCorrectionTarget","gotCorrectionTarget","onMoveTargetFromOuter","targetIndex","findIndex","triggeredToggleMousedown","active","isOutRootNode","isActiveCover","isOutList","outListExitHandler","isEnterFromCover","exited","keyExitHandler","keyListExitHandler","prevBeforeRecord","prevIBeforeRecord","curIBeforeRecord","curBeforeRecord","clickListItemHandler","clickExitHandler","clickListExitHandler","targetItem","find","window","safari","focusExitHandler","_ref4","_ref5","_exitsCover$i","origin","exitCoverHandler","toggle","_outListExits$i","exitHandlerWithCondition","condition","stringOrNode","_loop3","types","allTypes","ifKey","_getKeyNodes5","toggleEntryAndExit","toggleHandler"],"mappings":"o0DACO,IAAMA,EAAW,SAAAC,GAAG,OAAIC,OAAOC,UAAUC,SAASC,KAAKJ,EAAI,EAGrDK,EAAQ,SAAAL,GAAG,MAAsB,oBAAlBD,EAASC,EAA0B,EAGlDM,EAAQ,SAAAC,GAAG,MAAsB,sBAAlBR,EAASQ,EAA4B,EAGpDC,EAAmB,WAAH,OAASC,SAASC,aAAa,EAM/CC,EAAU,SAAAC,GAAC,MAAiB,iBAANA,GAHNC,EAGqCD,EAH9BH,SAASK,cAAcD,IAGYD,EAH1C,IAAAC,CAG2C,EAG3DE,EAAO,SAASC,GAC3BC,WAAWD,EAAI,EACjB,EAYaE,EAAe,SAASN,GACnC,MAAiB,UAAVA,EAAEO,KAAiC,KAAdP,EAAEQ,OAChC,EAGaC,EAAgB,SAAUT,GACrC,MAAiB,WAAVA,EAAEO,KAA8B,QAAVP,EAAEO,KAA+B,KAAdP,EAAEQ,OACpD,EAGaE,EAAa,SAASV,GACjC,MAAiB,QAAVA,EAAEO,KAA+B,IAAdP,EAAEQ,OAC9B,EAGaG,EAAe,SAASX,GACnC,OAAOU,EAAWV,KAAOA,EAAEY,QAC7B,EAGaC,EAAgB,SAASb,GACpC,OAAOU,EAAWV,IAAMA,EAAEY,QAC5B,ECpDME,EAAQ,SAASd,GDqBU,IAASe,ECpBxCf,EAAEc,SDoBsCC,ECnBlBf,GDqBfgB,SAC0B,UAA/BD,EAAKC,QAAQC,eACU,mBAAhBF,EAAKG,QCtBZlB,EAAEkB,QACN,EAGMC,EAAY,SAASnB,GAChB,MAALA,EAAWG,GAAK,WAAA,OAAMH,GAAKc,EAAMd,EAAE,IAClCc,EAAMd,EACb,EAGMoB,EAAY,SAASC,EAAMrB,EAAGsB,EAAOC,GAEzC,IADA,IACsBC,EADlBC,GAAU,EACdC,EAAAC,EAAkBN,KAAIG,EAAAE,KAAAE,MAAE,CAAA,IAAbrB,EAAGiB,EAAAK,MACZ,GAAInC,EAAMa,GACRkB,EAAUlB,EAAIP,EAAGsB,EAAOC,OACnB,CACL,IAAQO,EAAsCvB,EAAtCuB,MAAOC,EAA+BxB,EAA/BwB,KAAMC,EAAyBzB,EAAzByB,IAAKC,EAAoB1B,EAApB0B,KAAMC,EAAc3B,EAAd2B,UAChCT,GAAYK,GAAS9B,EAAEY,YAAekB,GAAS9B,EAAEY,aAC7CmB,GAAQ/B,EAAEmC,WAAcJ,GAAQ/B,EAAEmC,YAClCH,GAAOhC,EAAEoC,UAAaJ,GAAOhC,EAAEoC,WAC/BH,GAAQjC,EAAEqC,WAAcJ,GAAQjC,EAAEqC,YACtB,MAAbH,GAAsBA,IAAclC,EAAEO,IAC3C,CACA,GAAIkB,EAAS,OAAOA,CACtB,CACA,OAAOA,CACT,EAGMa,EAAc,SAASjB,EAAMkB,GACjC,MAAO,GAAGC,OAAOnB,GAAMoB,KAAI,SAAAC,GAAC,MAAiB,iBAANA,EDsCX,SAASzC,GAOrC,IANA,IAKI0C,EALEC,EAAa3C,EAAI4C,QAAQ,KACzBC,GAA2B,IAAhBF,EAAoB3C,EAAqB,IAAf2C,EAAmB,IAAM3C,EAAI8C,MAAM,EAAGH,GAC3EI,EAAW/C,EAAIgD,QAAQH,EAAU,IACjCzB,EAAO,CAACyB,GACRI,EAAM,gBAENP,EAAMO,EAAIC,KAAKH,IACnB3B,EAAK+B,KAAKT,EAAI,GAAGI,MAAM,IAYzB,IAXA,IAAIjB,GAAQ,EACRC,GAAO,EACPC,GAAM,EACNC,GAAO,EACPC,EAAY,KACZmB,EAAe,IAAIC,IAAI,CACzB,CAAC,QAAS,WAAA,OAAMxB,GAAQ,IACxB,CAAC,OAAQ,WAAA,OAAMC,GAAO,IACtB,CAAC,MAAO,WAAA,OAAMC,GAAM,IACpB,CAAC,UAAW,WAAA,OAAMC,GAAO,CAAI,KAEvBsB,EAAI,EAAGA,EAAIlC,EAAKmC,SAAWD,EAAG,CACpC,IAAME,EAAYJ,EAAaK,IAAIrC,EAAKkC,IACvB,MAAbE,EACFvB,EAAYb,EAAKkC,GACdE,GACP,CACA,MAAO,CACL3B,MAAAA,EACAC,KAAAA,EACAC,IAAAA,EACAC,KAAAA,EACAC,UAAAA,EAEJ,CCvE0DyB,CAAejB,GAAKA,QAAAA,EAAKH,IACnF,EAGMqB,EAAc,SAASC,EAASC,EAAUC,GAAU,IAAAC,EACxD,OAAuBA,QAAvBA,EAAOjE,EAAQ8D,UAAQG,IAAAA,EAAAA,EDiBmB,SAASC,EAAGC,GACtD,GAAS,MAALD,GAAkB,MAALC,EAAW,OAAO,KACnC,GAAID,EAAEE,SAASD,GAAI,OAAOD,EAC1B,GAAIC,EAAEC,SAASF,GAAI,OAAOC,EAE1B,IAAME,EAAQ,IAAIC,MAOlB,OANAD,EAAME,eAAeL,GACrBG,EAAMG,YAAYL,GACdE,EAAMI,YACPJ,EAAME,eAAeJ,GACrBE,EAAMG,YAAYN,IAEdG,EAAMK,uBACf,CC9B6BC,CAA6BZ,EAAUC,EACpE,EAGMY,EAAe,SAASC,GAC5B,IAAMC,EAAOD,EAAQnC,KAAI,SAAAqC,GAAI,OAAI/E,EAAQ+E,EAAK,IAAEC,QAAO,SAAAD,GAAI,OAAY,MAARA,KACzDE,EAAOH,EAAK,GACZI,EAAOJ,EAAK9B,OAAO,GAAG,GAC5B,MAAO,CAAE8B,KAAAA,EAAMG,KAAAA,EAAMC,KAAAA,EACvB,EAGMC,EAAe,SAASC,EAAUC,EAAaC,GACnD,OAAOD,EAAcC,EAAOtF,EAAQoF,EACtC,EAGMG,EAAc,SAASC,EAAYC,EAAYC,EAAaL,GAChE,IAAAM,EAA6Bf,EAAaa,GAAlCX,EAAIa,EAAJb,KAAMG,EAAIU,EAAJV,KAAMC,EAAIS,EAAJT,KACdI,EAAOzB,EAAY2B,EAAYP,EAAMC,GAG3C,MAAO,CACLI,KAAAA,EACAR,KAAAA,EAAMG,KAAAA,EAAMC,KAAAA,EACZU,MALYT,EAAaO,EAAaL,EAAaC,GAOvD,EAGMO,EAAe,SAASC,EAAKC,GACjC,IACMC,EADaC,MAAMC,QAAQH,EAAI/E,MACV+E,EAAI/E,KAAK0B,KAAI,SAAAyD,GAAC,OAAAC,KACpCL,EAAG,CACN/E,KAAMmF,GACN,IAAIJ,EACN,OAAOD,EAAIrD,OAAOuD,EACpB,EAGMK,EAAa,SAASC,EAAOhB,GAEjC,IAEAiB,EAA2FD,EAAME,QAAO,SAACV,EAAK7F,GAC5G,IAHkBe,EAGbR,EAAsDsF,EAAG,GAApDW,EAAiDX,EAAG,GAA7C/E,EAA0C+E,EAAG,GAAtCY,EAAmCZ,EAAG,GAA1Ba,EAAuBb,EAAG,GAAdc,EAAWd,EAAG,GACxDe,EAAc,SAAAC,GAAI,IAAAC,EAAA,OAAU,QAAVA,EAAI9G,EAAE6G,YAAI,IAAAC,OAAA,EAANA,EAAQC,SAASF,EAAK,EAWlD,OAfkB9F,EAKFf,EAAEe,KALQrB,EAAMqB,IAAkB,MAARA,GAAgBsE,EAAKlB,SAASpE,EAAQgB,KAAmB,MAARA,GAMrF6F,EAAY,aAAYrG,EAAMA,EAAIiC,OAAOxC,IACzC4G,EAAY,WAAUJ,EAAQA,EAAMhE,OAAOxC,IAC3C4G,EAAY,WAAU9F,EAAQA,EAAM0B,OAAOxC,IAC3C4G,EAAY,aAAYD,EAAUA,EAAQnE,OAAOxC,MAEjD4G,EAAY,WAAUH,EAAaA,EAAWjE,OAAOxC,IACrD4G,EAAY,WAAUF,EAAaA,EAAWlE,OAAOxC,IACrD4G,EAAY,aAAYD,EAAUA,EAAQnE,OAAOxC,KAEhD,CAACO,EAAKiG,EAAO1F,EAAO2F,EAAYC,EAAYC,EACpD,GAAE,IAAIX,MAAM,GAAGgB,KAAK,KAddC,EAAQX,EAAA,GAAEY,EAAUZ,EAAA,GAAEa,EAAUb,EAAA,GAAEc,EAAed,EAAA,GAAEe,EAAef,EAAA,GAAEgB,EAAYhB,EAAA,GAoBvF,MAAO,CACLW,SAAAA,EAAUC,WAAAA,EAAYC,WAAAA,EAAYI,cALdL,EAAW1D,OAAS,EAKSgE,cAJ7BL,EAAW3D,OAAS,EAIwBiE,YAH9CR,EAASzD,OAAS,EAIpC4D,gBAAAA,EAAiBC,gBAAAA,EACjBC,aAAAA,EAEJ,EAGMI,EAAW,SAASC,EAAMC,EAAUC,EAAclC,EAAOmC,EAASC,GAAa,IAAAC,EAAAC,EAE/EC,EAAY,GAAG1F,OAAOmF,GAAM5C,QAAO,SAAAoD,GAAC,OAAS,MAALA,CAAS,IAClD1F,KAAI,SAAA2F,GAAG,OAAI3I,EAAM2I,GAAOA,EAAM,CAAErH,KAAMqH,EAAK,IAC3C3F,KAAI,SAAAzC,GAAC,IAAAqI,EAAAC,EAAA,OAAAnC,KACDnG,EAAC,CACJuI,eAAgC,QAAlBF,EAAErI,EAAEuI,sBAAc,IAAAF,GAAAA,EAChCG,MAAc,QAATF,EAAEtI,EAAEwI,aAAK,IAAAF,EAAAA,EAAIP,EAElBlB,UAAiB4B,IAAXzI,EAAE6G,KAAqB,CAAU,MAAT7G,EAAEO,IAAc,GAAK,UAAqB,MAAVP,EAAEe,KAAe,GAAK,SAASgE,QAAO,SAAA2D,GAAC,MAAU,KAANA,CAAS,IAAG,GAAGlG,OAAOxC,EAAE6G,MACjItG,IAAK+B,EAAYtC,EAAEO,MACnB,IACDgG,OAAOX,EAAc,IACpB+C,EAAYjJ,EAAMkI,GAAYA,GAAwB,IAAbA,EAAoC,QAAnBI,EAAeC,QAAfA,EAAGC,EAAU,UAAVD,IAAYA,OAAZA,EAAAA,EAAcW,UAAE,IAAAZ,EAAAA,EAAK,WAAM,EAAMJ,EAWlG,MAFc,CAPKlI,EAAMiJ,GAAa,CACpC5H,KAAM,KACNR,IAAK,CAACE,GACNmI,GAAID,EACJE,OAAQhB,EAAelC,EAAQmC,EAC/BjB,KAAM,CAAC,YACL,MACuBrE,OAAO0F,GAAWnD,QAAO,SAAA/E,GAAC,OAAS,MAALA,IAG3D,EAGM8I,EAAiB,SAASN,EAAOO,GAErC,IAAAC,EAMA,WAEE,IAAMC,EAAkBvJ,EAAM8I,GACxBU,EAAWD,GAAmBT,EAAMO,GACpCI,EAAeF,GAA0C,qBAAvB9J,EAAS+J,IAA6D,mBAAlBA,EAASE,KAC/FC,EAAgBJ,IAAoBE,EACpCG,GAAeH,IAAiBE,EACtC,MAAO,CACLF,aAAAA,EACAE,cAAAA,EACAC,YAAAA,EACAJ,SAAAA,EAEJ,CAnB+DK,GAAvDJ,EAAYH,EAAZG,aAAcE,EAAaL,EAAbK,cAAeC,EAAWN,EAAXM,YAAaJ,EAAQF,EAARE,SAC9CC,EAAcD,EAASE,KAAKL,GACvBM,GACAC,GAAaP,GAiBxB,EAGMS,EAAY,SAASX,EAAQlD,EAAOd,EAAMQ,EAAMwC,EAAc4B,EAAaC,EAAe1J,GAC9F,IAAM2J,EAAkB,SAAAjB,GAAC,OAAS,MAALA,IAAmB,IAANA,CAAU,EAEpD,GAAIiB,EAAgBd,GAClB,OAAOe,IAEJ,GAAIlK,EAAMmJ,GAAS,CACtB,IAAMgB,EAAYhB,EAAO,CAAE7I,EAAAA,EAAG6E,KAAAA,EAAMc,MAAAA,EAAON,KAAAA,EAAMyE,KAAMjF,EAAK4E,GAAcM,MAAON,IACjF,OAAIE,EAAgBE,GACXD,IACFC,CACT,CAEK,OAAO9J,EAAQ8I,GAEpB,SAASe,IACP,OAAI/B,EAAqBlC,EACb+D,CACd,CACF,EAGMM,EAAc,WAAA,SAAAA,IAAAC,KAClBC,MAAQ,GAAED,KACVE,SAAU,CAAI,CAAA,IAAAC,EAAAJ,EAAA1K,UAmBb,OAnBa8K,EACdhH,KAAA,SAAKrC,EAAM8F,EAAMwD,GACfJ,KAAKE,SAAU,EACfF,KAAKC,MAAM9G,KAAK,CACdrC,KAAAA,EACA8F,KAAAA,EACAwD,QAAAA,KAEHD,EACDE,MAAA,WACEL,KAAKC,MAAQ,GACbD,KAAKE,SAAU,GAChBC,EACDG,aAAA,WACEN,KAAKC,MAAMM,SAAQ,SAAAC,GAAC,IAAAC,EAAA,OAAU,QAAVA,EAAID,EAAE1J,YAAF2J,IAAMA,OAANA,EAAAA,EAAQC,iBAAiBF,EAAE5D,KAAM4D,EAAEJ,aAC5DD,EACDQ,gBAAA,WACEX,KAAKC,MAAMM,SAAQ,SAAAC,GAAC,IAAAI,EAAA,OAAU,QAAVA,EAAIJ,EAAE1J,YAAF8J,IAAMA,OAANA,EAAAA,EAAQC,oBAAoBL,EAAE5D,KAAM4D,EAAEJ,YAC9DJ,KAAKK,SACNN,CAAA,CArBiB,GAyBde,EAAe,WAAA,SAAAA,IAAAd,KACnBC,MAAQ,IAAI5G,GAAK,CAAA,IAAA0H,EAAAD,EAAAzL,UAehB,OAfgB0L,EACjBC,IAAA,SAAIC,GACF,OAAOjB,KAAKC,MAAMe,IAAIC,IACvBF,EACD5H,KAAA,SAAK8H,EAAInK,EAAMsJ,GACTJ,KAAKgB,IAAIC,KACbnK,EAAK4J,iBAAiB,UAAWN,GACjCJ,KAAKC,MAAMiB,IAAID,EAAI,CACjBnK,KAAAA,EACAsJ,QAAAA,MAEHW,EACDI,OAAA,SAAOF,GAAI,IAAAG,EAAApB,KACG,GAAGzH,OAAO0I,GAClBV,SAAQ,SAAAU,GAAE,OAAIG,EAAKnB,MAAMxG,IAAIwH,GAAInK,KAAK+J,oBAAoB,UAAWO,EAAKnB,MAAMxG,IAAIwH,GAAIb,aAC7FU,CAAA,CAhBkB,GAoBfO,EAAO,WAAA,SAAAA,IAAArB,KACXsB,KAAO,GAAEtB,KACTjF,KAAO,KAAIiF,KACXhF,KAAO,KAAIgF,KACX3I,OAAS,EAAC2I,KACV1I,MAAQ,EAAC0I,KACTuB,MAAQ,KAAIvB,KACZwB,KAAO,KAAIxB,KACXyB,yBAA0B,EAAOzB,KACjC0B,yBAA0B,CAAK,CAAA,UAAAC,EAAAN,EAAAhM,UAY9B,OAZ8BsM,EAa/BC,OAAA,SAAOhH,GACLoF,KAAKsB,KAAKO,OAAO,EAAG7B,KAAKsB,KAAK/H,QAC9BwC,MAAM1G,UAAU8D,KAAK2I,MAAM9B,KAAKsB,KAAM1G,GACtCoF,KAAKjF,KAAOH,EAAK,GACjBoF,KAAKhF,KAAOJ,EAAKmH,IAAI,IACtBJ,EACDzB,QAAA,WACE,OAA4B,IAArBF,KAAKsB,KAAK/H,QAClBoI,EACDX,IAAA,SAAI1H,GACF,QAAS0G,KAAKsB,KAAKhI,IACpBqI,EACDK,OAAA,SAAOnG,EAAKvE,GACV0I,KAAKiC,WAAWjC,KAAKnE,IAAKmE,KAAK1I,MAC/B0I,KAAKkC,UAAUrG,EAAKvE,IACrBqK,EACDQ,YAAA,SAAYtG,GACNmE,KAAKnE,MAAQA,GAAoB,MAAZmE,KAAKnE,KAAsB,MAAPA,GAE7CmE,KAAKgC,OAAOnG,GAAM,IACnB8F,EACDM,WAAA,SAAWG,EAAM/K,GACf2I,KAAK3I,MAAQA,EAAQ,GAAK,EAAIA,EAC9B2I,KAAKoC,KAAOA,GAAQ,MACrBT,EACDO,UAAA,SAAUrG,EAAKvE,GACb0I,KAAK1I,KAAOA,EAAO,GAAK,EAAIA,EAC5B0I,KAAKnE,IAAMA,GAAO,MACnB8F,EACDU,oBAAA,SAAoB/K,GAClB,IAAMuE,EAAMmE,KAAKsB,KAAKhK,GAClB0I,KAAK1I,OAASA,GACZ0I,KAAK1I,KAAO,GAAKA,EAAO,GAE9B0I,KAAKgC,OAAOnG,EAAKvE,MAClB+J,KAAA,CAAA,CAAA/K,IAAA,OAAAmD,IA/CD,WACE,OAAOuG,KAAKuB,OAASvB,KAAKsB,KAAKtB,KAAK3I,QAAU,IAC/C,EAAA6J,IAID,SAASoB,GACPtC,KAAKuB,MAAQe,CACf,GAAC,CAAAhM,IAAA,MAAAmD,IALD,WACE,OAAOuG,KAAKwB,MAAQxB,KAAKsB,KAAKtB,KAAK1I,OAAS,IAC7C,EAAA4J,IAID,SAAQoB,GACNtC,KAAKwB,KAAOc,CACd,oFAACjB,CAAA,CArBU,UA4DI,WAAc,IAAAkB,EAAAC,EACvBC,EAAS,IAAKC,UAAAnJ,QAAA,OAAAiF,EAAAkE,UAAA,cAAoB3G,OAClC4G,EAAiB,EAAIF,EAAMC,GAAAA,UAAAnJ,QAAV,EAAIkJ,OAAMjE,EAAAkE,UAAV,EAAID,GACrBG,EAAiB,EAAIH,EAAMC,GAAAA,UAAAnJ,QAAV,EAAIkJ,OAAMjE,EAAAkE,UAAV,EAAID,GACrBI,EAA2B,QAApBN,EAAU,EAAIE,EAAM,GAAAC,UAAAnJ,QAAV,EAAIkJ,OAAMjE,EAAAkE,UAAV,EAAID,UAAM,IAAAF,EAAAA,EAAK,GAEtC,KAAMxG,MAAMC,QAAQ4G,IAAaA,EAASrJ,OAAS,GACjD,MAAM,IAAIuJ,MAAM,uCAElB,IAEEC,EA6CEF,EA7CFE,SAEAC,EA2CEH,EA3CFG,KAEAC,EAyCEJ,EAzCFI,KAEAb,EAuCES,EAvCFT,KAEAvE,EAqCEgF,EArCFhF,QAEAqF,EAmCEL,EAnCFK,MAEAxF,EAiCEmF,EAjCFnF,KAEAC,EA+BEkF,EA/BFlF,SAEAwF,EA6BEN,EA7BFM,QAEAC,EA2BEP,EA3BFO,OAEOC,EAyBLR,EAzBFnH,MAEA4H,EAuBET,EAvBFS,cAEAC,EAqBEV,EArBFU,iBAEAC,EAmBEX,EAnBFW,aAEA1F,EAiBE+E,EAjBF/E,YAAW2F,EAiBTZ,EAfFa,wBAAAA,OAA0B,IAAHD,GAAOA,EAE9BE,EAaEd,EAbFc,yBAAwBC,EAatBf,EAXFgB,0BAAAA,OAA4B,IAAHD,GAAOA,EAAAE,EAW9BjB,EATFkB,gBAAiBC,OAAsB,IAAHF,GAAQA,EAE5CxF,GAOEuE,EAPFvE,eAEA2F,GAKEpB,EALFoB,OAAMC,GAKJrB,EAHFsB,iCAAAA,QAAmC,IAAHD,IAAOA,GAMnCE,GAAU,GAAG7L,OAAO2K,GACvBpI,QAAO,SAAAoD,GAAC,OAAS,MAALA,CAAS,IACrB1F,KAAI,SAAA2F,GAAG,OAAI3I,EAAM2I,GAAOA,EAAM,CAAErH,KAAMqH,EAAK,IAC3C3F,KAAI,SAAA0K,GAAK,IAAAmB,EAAAC,EAAA,OAAApI,KACLgH,EAAK,CACR5E,eAAoC,QAAtB+F,EAAEnB,EAAM5E,sBAAc,IAAA+F,GAAAA,EACpC9F,MAAkB,QAAb+F,EAAEpB,EAAM3E,aAAK,IAAA+F,EAAAA,EAAId,EACtB5G,UAAqB4B,IAAf0E,EAAMtG,KAAqB,CAAc,MAAbsG,EAAM5M,IAAc,GAAK,UAAyB,MAAd4M,EAAMpM,KAAe,GAAK,SAASgE,QAAO,SAAA2D,GAAC,MAAS,IAALA,CAAQ,IAAG,GAAGlG,OAAO2K,EAAMtG,MAChJ2H,QAAyB,IAAjBrB,EAAMqB,OAAkBrB,EAAMvE,GAAKuE,EAAMqB,OACjDjO,IAAK+B,EAAY6K,EAAM5M,MACvB,IACDgG,OAAOX,EAAc,IAElB6I,GAAgC,IAAnBJ,GAAQ7K,OAErBkL,GAAU,IAAIC,IAAIN,GAAQ5L,KAAI,SAAAzC,GAAC,OAAIN,EAAMM,EAAEwO,QAAUxO,EAAEe,KAAO,IAAI,IAAEgE,QAAO,SAAAmB,GAAC,OAAS,MAALA,CAAS,IAAEzD,KAAI,SAAAyD,GAAC,OAAInG,EAAQmG,EAAE,KAEhH0I,GAAW7O,EAAQ+H,IAAqB2E,QAAdA,EAAI4B,GAAQ,cAAE5B,SAAVA,EAAY1L,OAG9C8N,GAMIpP,EAAM6N,GAAgBA,EAAe,CAAE,EAJnCwB,GAASD,GAAf9N,KACUgO,GAAaF,GAAvBG,SACSC,GAAYJ,GAArBK,QACMC,GAASN,GAAflH,KAGIE,GAA+B,MAAhByF,IAAyC,IAAjBA,IAAwC,IAAdwB,GAEjE1J,GAAcyC,MAAkC,IAAjByF,IAAuC,IAAdwB,IAAmC,MAAbA,IAE9EM,GAAa,GAAG5M,OAAO2M,IAC1BpK,QAAO,SAAA/E,GAAC,OAAS,MAALA,CAAS,IACrByC,KAAI,SAAAzC,GAAC,OAAIP,EAAMO,GAAKA,EAAI,CAAEO,IAAKP,EAAG,IAClCyC,KAAI,SAAAzC,GAAC,IAAAqP,EAAA,OAAAlJ,KACDnG,EAAC,CACJ6I,OAAgB,QAAVwG,EAAErP,EAAE6I,cAAM,IAAAwG,EAAAA,EAAIT,GACpBrO,IAAK+B,EAAYtC,EAAEO,MAAI,IAGrB+O,GAAqBzH,IAAsC,IAAtBuH,GAAW5L,OAIhDqB,GAAO,IAAIyG,EAEbjG,GAAO,KAEPM,GAAQ,KAEZd,GAAKqH,WAAW,KAAMqB,QAAAA,GAAkB,GAExC,IAAMgC,GAAU9P,EAAMyN,GAAQA,EAAO,CAAE3M,IAAK2M,GAC5CsC,GAAArJ,EAAA,CAAA,EAIKoJ,GAAO,CACVhP,IAAK+B,EAAYiN,GAAQhP,IAAKI,KAJzB8O,GAAMD,GAAXjP,IACImP,GAAMF,GAAV5G,GAMI+G,GAAUlQ,EAAM4M,GAAQA,EAAO,CAAE9L,IAAK8L,GAC5CuD,GAAAzJ,EAAA,CAAA,EAIKwJ,GAAO,CACVpP,IAAK+B,EAAYqN,GAAQpP,IAAKM,KAJzBgP,GAAMD,GAAXrP,IACIuP,GAAMF,GAAVhH,GAOImH,IAA2B,IAAbnI,EAGdoI,KAAY/C,SAAAA,GAGZgD,MAAwB/C,GAAQb,GAAQW,GAGxCkD,GAAqB3H,SAAAA,GAAkB0H,GAGzCE,IAAc,EAEdC,IAAe,EAGbC,GAAgB,IAAIrG,EAEpBsG,GAAiB,IAAItG,EAErBuG,GAAc,IAAIxF,EAExB,IAAKmD,KAEHsC,MAG2B/B,GAAa,CAAC,CAAA,GAAMJ,IAASoC,MAAK,SAAAC,GAAQ,OAAAA,EAALlI,UAEzC,CAErB,IAAAmI,GAEIrL,EAAYsH,EAAUC,EAAUiC,GAAW1J,IADvCwL,GAAOD,GAAbtL,KAAqBwL,GAAOF,GAAb9L,KAAsBiM,GAAQH,GAAfhL,MAEhCd,GAAKgH,OAAOgF,IAIZE,GAHA1L,GAAOuL,GAGwB/L,GAF/Bc,GAAQmL,GAGV,CAGF,IAAME,GAAS,CAEbC,MAAK,SAAC9D,GAGJ,GAFAyB,GAAWA,IAAYhP,IAEnBuN,EAEF,OAAO+D,GAAa,CAAEC,YAAY,GADJhE,EAAtBvE,GAAsBuE,EAAlBtE,OAAkBsE,EAAV3E,OAGpB,IADK,IAAA4I,EAAAA,WAEH,IAAAC,EAA0ChD,GAAQ9K,GAA1CqF,EAAEyI,EAAFzI,GAAI/B,EAAIwK,EAAJxK,KAAM9F,EAAIsQ,EAAJtQ,KAAM8H,EAAMwI,EAANxI,OAAQL,EAAK6I,EAAL7I,MAGhC,GAAI3B,SAAAA,EAAM4J,MAAK,SAAA5J,GAAI,OAAY,MAARA,IAAyB,IAATA,GAFpB,WAEsCA,CAAmB,KAAa,MAAR9F,EAAc,MAAA,CAAAwL,EACtF2E,GAAa,CAAEC,YAAY,GAAQvI,EAAIC,EAAQL,KALjDjF,EAAI,EAAGA,EAAI8K,GAAQ7K,SAAWD,EAAC,CAAA,IAAA+N,EAAAF,IAAA,GAAA,iBAAAE,EAAA,OAAAA,EAAA/E,CAAA,CAQxC,OAAO2E,GAAa,CAAEC,YAAY,GAErC,EAEDxJ,KAAI,SAAC4J,GAEH,IAAAC,EAIIlM,EAAYsH,EAAUC,EAAUiC,GAAW1J,IAHvCyL,EAAOW,EAAb3M,KACAc,EAAK6L,EAAL7L,MACAN,EAAImM,EAAJnM,KAGF,GAAIkM,EAAU,CACZ,IAAQ3I,EAA6B2I,EAA7B3I,GAAY6I,EAAiBF,EAAzB1I,OAEZ,OAAO6I,EADQ3R,EAAQ0R,GACD7I,EACxB,CAEE,IADA,IAAMvC,EAAQqB,EAASC,EAAMC,EAAUC,GAAclC,EAAOiJ,GAAU7G,GAAa4J,EAAAA,WAEjF,IAAAC,EAA6BvL,EAAM9C,GAA3BqF,EAAEgJ,EAAFhJ,GAAI/B,EAAI+K,EAAJ/K,KAAMgC,EAAM+I,EAAN/I,OAGlB,GAAIhC,SAAAA,EAAM4J,MAAK,SAAA5J,GAAI,OAAY,MAARA,IAAyB,IAATA,GAFpB,WAEsCA,CAAmB,IAAG,MAAA,CAAA0F,EACtEmF,EAAO7I,EAAQD,KALjBrF,EAAI,EAAGA,EAAI8C,EAAM7C,SAAWD,EAAC,CAAA,IAAAsO,EAAAF,IAAA,GAAA,iBAAAE,EAAA,OAAAA,EAAAtF,CAAA,CAUxC,SAASmF,EAAO7I,EAAQD,GAItB,OAFI/D,GAAKsF,WAAWtF,GAAKgH,OAAOgF,GAEzBiB,GAAY,CAAEX,YAAY,GAAQvI,EAAIC,GAAQ,EAAOlD,EAAOd,GAAK0G,KAAMlG,EAChF,CACD,EAEDuF,gBAAeA,WACbyF,GAAczF,kBACd0F,GAAe1F,iBAChB,EAEDmH,2BAA0BA,WACxB1B,GAAczF,iBACf,EAEDoH,qBAAoBA,WAClB1B,GAAe1F,iBAChB,EAED4F,kBAAiBA,WACfA,IACD,EAEDyB,wBAAuBA,WAErB,IAAAC,EAII5M,EAAYsH,EAAUC,EAAUiC,GAAW1J,IAH7CC,EAAI6M,EAAJ7M,KACMwL,EAAOqB,EAAbrN,KACAc,EAAKuM,EAALvM,MAEEd,GAAKsF,WAAWtF,GAAKgH,OAAOgF,GAEhCE,GAAyB1L,EAAMR,GAAMc,EACtC,EAEDwM,WAAUA,SAACjH,EAAIkH,GACb,IAAIC,EAAO,KACX,GAAI3S,EAAM0S,GAAU,CAClB,IAAAE,EAIIhN,EAAYsH,EAAUC,EAAUiC,GAAW1J,IAE/CiN,EAAOD,EAAQ,CAAE/M,KALXiN,EAAJjN,KAKqBR,KAJPyN,EAAdzN,KAIqCG,KAJjBsN,EAAJtN,KAI2BC,KAJjBqN,EAAJrN,KAI2BU,MAH5C2M,EAAL3M,MAGwDpE,KAAMsD,GAAKtD,KAAMD,MAAOuD,GAAKvD,aAEpF+Q,EAAOD,EAEZ,IAAAG,EAA0EF,EAA5DG,EAAWD,EAAjBxR,KAAmB6H,EAAE2J,EAAF3J,GAAS6J,EAAUF,EAAfhS,IAAyBmS,EAAaH,EAArB1J,OAC1C9H,EAAOhB,EAAQyS,GACf3J,EAAS9I,EAAQ2S,GACjBrR,EAAOiB,EAAYmQ,GACzBlC,GAAYnN,KAAK8H,EAAInK,GAAM,SAAAf,GACrBoB,EAAUC,EAAMrB,EAAG6E,GAAKvD,MAAOuD,GAAKtD,QACtCvB,EAAEuI,iBACFK,SAAAA,IACAzH,EAAU0H,GAEd,GACD,EAED8J,cAAa,SAACzH,GACZqF,GAAYnF,OAAOF,EACpB,EAED0H,WAAU,SAAC/B,GACT,IAAMgC,EAAWhC,EAAQpO,KAAI,SAAAqC,GAAI,OAAI/E,EAAQ+E,EAAK,IAAEC,QAAO,SAAAD,GAAI,OAAY,MAARA,KACnED,GAAKgH,OAAOgH,EACb,EAEDtP,EAAC,SAACuP,GACA,GAAIjO,GAAKoG,IAAI6H,IAAS3C,GAAa,CACjCtL,GAAKyH,oBAAoBwG,GACzB,IAAQzG,EAA2BxH,GAA3BwH,KAAM/K,EAAqBuD,GAArBvD,MAAOwE,EAAcjB,GAAdiB,IAAKvE,EAASsD,GAATtD,KAG1B,OAFA8L,SAAAA,EAAS,CAAErN,EAAG,CAAE+S,OAAO,GAAQ1G,KAAAA,EAAM/K,MAAAA,EAAOwE,IAAAA,EAAKvE,KAAAA,IACjDT,EAAM+L,EAAStL,IACRuR,CACT,CACK,OAAOjO,GAAKtD,KAAO,EAAIsD,GAAKvD,MAAQuD,GAAKtD,IAChD,GAGF,OAAOyP,GAGP,SAASE,GAAalR,EAAGkP,EAASrG,EAAQL,EAAOD,EAAgByF,GAAiB,IAAAgF,EAAAC,EAahF,SAASC,IAEP,GAAIrO,GAAKsF,UAAW,CAClB,IAAc0G,EAAYlM,EAAakI,GAA/BhI,KACRA,GAAKgH,OAAOgF,EACd,CAEY,MAARxL,KACFA,GAAOzB,EAAYgJ,EAAU/H,GAAKG,KAAMH,GAAKI,OAElC,MAATU,IAAiBkC,KACnBlC,GAAQT,EAAa4J,GAAW1J,GAAaC,KAE1C6I,IACH6C,GAAyB1L,GAAMR,GAAMc,KACxB,IAAXkD,GAIN,SAAqBlD,EAAOwN,EAAUvG,GACpC,IAAM/H,EAAOsO,EAAS5H,KACdc,EAAqB8G,EAArB9G,KAAMrH,EAAemO,EAAfnO,KAAMzD,EAAS4R,EAAT5R,KACdmI,EAAgB2C,GAAQrH,EACxB6E,EAAYL,EAAUX,EAAQlD,EAAOd,EAAM+H,EAAU/E,GAActG,EAAMmI,EAAe1J,GAC9F,GAAIiQ,GAAoB,CACtB,IAAMmD,EAAYvO,EAAKhC,QAAQgH,GAC/B,GAAIuJ,GAAa,EAAG,CAClBD,EAAS7G,oBAAoB8G,GAC7B,IAAQtN,EAAcqN,EAAdrN,IAAKvE,EAAS4R,EAAT5R,KACb8L,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAM,KAAMvG,IAAAA,EAAKxE,OAAQ,EAAGC,KAAAA,IAC1C4O,IAAc,CAChB,CACF,MACE,GAAIvD,EAASzI,SAAS0F,IAAcA,IAAclE,EAAO,CACvDwN,EAAS/G,YAAYvC,GACrB,IAAQ/D,EAAcqN,EAAdrN,IAAKvE,EAAS4R,EAAT5R,KACb8L,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAM,KAAMvG,IAAAA,EAAKxE,OAAQ,EAAGC,KAAAA,IAC1C4O,IAAc,CAChB,EAEEtI,IAAiBgC,IAAclE,IAAyB,IAAhBwK,KAAuBC,IAAe,GAClFjP,EAAU0I,EACZ,CA1BIwJ,CAAY1N,GAAOd,GAAMQ,GAC7B,CA3BI+K,IAAgBD,KAEpB5H,IAAkC,QAApByK,EAAIhT,EAAEuI,sBAAc,IAAAyK,GAAhBA,EAAAxT,KAAAQ,IAClBgO,IAAoC,QAArBiF,EAAIjT,EAAEgO,uBAAe,IAAAiF,GAAjBA,EAAAzT,KAAAQ,IAEnBsT,QAAQC,QAAQrE,aAAAA,EAAAA,EAAUlP,IAAIoJ,MAAK,SAAAoK,GACjC1K,EAAeN,EAAO0K,EACxB,IA8CF,CAGA,SAASpB,GAAY9R,EAAG4I,EAAIC,EAAQL,EAAO7C,EAAO8N,EAAUpO,EAAMqO,EAAInL,EAAgByF,GAAiB,IAAA2F,EAAAC,EAErG,IAAKzD,IACDzQ,EAAMgU,KAAMA,EAAG,CAAE1T,EAAAA,EAAGqM,KAAMxH,GAAKwH,KAAMvG,IAAKjB,GAAKiB,IAAKxE,MAAOuD,GAAKvD,MAAOC,KAAMsD,GAAKtD,OACpF,OAAO,EAETgH,IAAkCoL,QAApBA,EAAI3T,EAAEuI,sBAAFoL,IAAgBA,GAAhBA,EAAAnU,KAAAQ,IAClBgO,IAAoC,QAArB4F,EAAI5T,EAAEgO,uBAAe,IAAA4F,GAAjBA,EAAApU,KAAAQ,IAEfiQ,GAAoBpL,GAAKyH,qBAAqB,GAC7CzH,GAAKuH,YAAY,MAEtB+D,IAAc,EAEd,IAAMtG,EAAYL,EAAUX,EAAQlD,EAAO8N,EAAUpO,EAAMwC,GAAchD,GAAKtD,KAAMqN,GAAU5O,GAE9F,OAAI6J,EAIJ,WAME,SAASgK,IACF3F,KACCrE,IAAclE,GAChBoM,KACEjE,GACF0C,MAEJnD,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAMxH,GAAKwH,KAAMvG,IAAK,KAAMxE,MAAOuD,GAAKvD,MAAOC,MAAO,IACpET,EAAM+I,EACR,CAbAyJ,QAAQC,QAAQ3K,aAAAA,EAAAA,EAAK5I,IAAIoJ,MAAK,SAAAoK,GAC5B1K,EAAeN,EAAOqL,EACxB,GAYF,CApBsBC,GAuBtB,WAeE,SAASD,EAAyBR,GAChC,OAAO,SAAAG,GACAtF,KACH6D,KACIjE,GACF0C,MAEJnD,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAMxH,GAAKwH,KAAMvG,IAAK,KAAMxE,MAAOuD,GAAKvD,MAAOC,MAAO,IACpE8R,GAAevS,EAAMuS,GAEzB,CAvBAC,QAAQC,QAAQ3K,aAAAA,EAAAA,EAAK5I,IAAIoJ,MAAK,SAAAoK,GAE5B,IAAkB,IAAd3J,EAAJ,CAOA,IAAMkK,EAAkCF,EAAyBjF,IACjE9F,EAAeN,EAAOuL,EAHtB,KALA,CAEsCF,GACpCG,EAEF,CAIF,GAaF,CAhDYC,EAiDd,CAGA,SAASlD,GAAyB1L,EAAM8N,EAAUxN,GAEhD,IAAMd,EAAOsO,EAAS5H,KAChBvG,EAAOmO,EAASnO,KAChBC,EAAOkO,EAASlO,KAEtB,GAAKoL,GAAclG,QAAnB,CAEA,GAAY,MAAR9E,EACF,MAAM,IAAI0H,MAAK,UAAWH,EAAQ,+BAA+BA,EAAQ,eAC3E,GAAY,MAAR5H,GAAwB,MAARC,EAClB,MAAM,IAAI8H,MAAM,sDAMlB,WAGE,IAAImH,GAA4B,EAI1BC,EAAgB,WAAH,QAAS1F,IAAoB0B,EAAW,EAGrDiE,EAAqBnE,GAoQ3B,SAAqCjQ,GACnC,GAAIA,EAAE6I,SAAWlD,EAAO,OACxB,IAAKwO,IAAiB,OAEtB,IAAAE,EA7Q2B,CAAClB,EAAS5R,KAAM4R,EAAS7G,oBAAoBgI,KAAKnB,IA6QtEoB,EAAMF,EAAA,GAAEG,EAAQH,EAAA,GACjBI,EAAQC,KAAKC,IAAI,EAAGJ,GACpBK,EAAW/P,EAAKrB,OAClBqR,GAAU,EAEd,GAAIzT,EAAUqO,GAAQzP,EAAGmT,EAAS7R,MAAO6R,EAAS5R,MAAO,CACvD,IAAMuT,EAAaL,EAAQ,EACvBM,EAAQ/E,GAAU0E,KAAKM,IAAIJ,EAAW,EAAGE,GAAcA,EAC3DC,GAASH,EACTlF,UAAAA,GAAS,CAAE1P,EAAAA,EAAGqM,KAAMxH,EAAK4P,GAAQ3O,IAAKjB,EAAKkQ,GAAQzT,MAAOmT,EAAOlT,KAAMwT,IACvE1H,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAMxH,EAAK4P,GAAQ3O,IAAKjB,EAAKkQ,GAAQzT,MAAOmT,EAAOlT,KAAMwT,IACvEP,EAASO,GACTjU,EAAM+D,EAAKkQ,IACXF,GAAU,CACZ,MACK,GAAIzT,EAAUyO,GAAQ7P,EAAGmT,EAAS7R,MAAO6R,EAAS5R,MAAO,CAC5D,IAAM0T,EAAaR,EAAQ,EACvBM,EAAQ/E,GAAU0E,KAAKC,IAAI,EAAGM,GAAcA,EAChDF,GAASA,EAAQH,GAAYA,EAC7B9E,UAAAA,GAAS,CAAE9P,EAAAA,EAAGqM,KAAMxH,EAAK4P,GAAQ3O,IAAKjB,EAAKkQ,GAAQzT,MAAOmT,EAAOlT,KAAMwT,IACvE1H,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAMxH,EAAK4P,GAAQ3O,IAAKjB,EAAKkQ,GAAQzT,MAAOmT,EAAOlT,KAAMwT,IACvEP,EAASO,GACTjU,EAAM+D,EAAKkQ,IACXF,GAAU,CACZ,EAGW,QAAV7U,EAAEO,KAAiBsU,IAAY3E,IAAsBlQ,EAAEuI,iBACxDsM,GAAW5G,GAAuBjO,EAAEgO,iBACtC,EAGA,SAAkChO,GAChC,IAAMgF,EAAOH,EAAK,GACZI,EAAOJ,EAAKmH,IAAI,GAChBkJ,EAAUlV,EAAE6I,OAClB,GAAIqM,IAAYvP,EAAO,OACvB,IAAKwO,IAAiB,OAEtB,IAAIgB,GAAuB,EACvBN,GAAU,EACVlU,EAAaX,IACfmT,EAAS/G,YAAY8I,GACrB/B,EAASxH,yBAA0B,EAC/BuJ,IAAYjQ,IACdkQ,GAAuB,EAClBnF,IAASlP,EAAMkE,IAElBkQ,IAAY7P,IACd8P,GAAuB,EACvBrU,EAAMkE,IAER6P,GAAU,GAEHhU,EAAcb,KACrBmT,EAAS/G,YAAY8I,GACrB/B,EAASzH,yBAA0B,EAC/BwJ,IAAYlQ,IACdmQ,GAAuB,EAClBnF,IAASlP,EAAMmE,IAElBiQ,IAAY7P,IACd8P,GAAuB,EACvBrU,EAAMmE,IAER4P,GAAU,IAGRM,GAAyBN,GAAW3E,KAAqBlQ,EAAEuI,iBAC3DsM,GAAW5G,GAAqBjO,EAAEgO,iBACxC,EA3UM3H,EAAQqB,EAASC,EAAMC,EAAUC,GAAclC,EAAOiJ,GAAU7G,GACtEqN,EAIIhP,EAAWC,EAAOhB,GAHpB4B,EAAQmO,EAARnO,SAAUC,EAAUkO,EAAVlO,WAAYC,EAAUiO,EAAVjO,WAAYI,EAAa6N,EAAb7N,cAAeC,EAAa4N,EAAb5N,cAAeC,EAAW2N,EAAX3N,YAChEL,EAAegO,EAAfhO,gBAAiBC,EAAe+N,EAAf/N,gBACjBC,EAAY8N,EAAZ9N,aAII+N,EAA6BjO,EAAgB3E,KAAI,SAAAkF,GAAI,MAAI,CAAC5H,EAAQ4H,aAAAA,EAAAA,EAAM5G,MAAOuU,EAA0B3N,OACzG4N,EAA6BlO,EAAgB5E,KAAI,SAAAkF,GAAI,MAAI,CAAC5H,EAAQ4H,aAAAA,EAAAA,EAAM5G,MAAOyU,EAA0B7N,OAE/G0I,GAAcjN,KAAKiC,EAAM,WA0EzB,SAA8BrF,GAG5B,IAAM6I,EAAS7I,EAAE6I,OAEX4M,EAAgBzV,EAAEyV,cAGxB,GAAIvB,EAEF,YADAA,GAA4B,GAK9B,GAAIrM,IAAgBgB,IAAWlD,EAE7B,YADAyK,IAAe,GAKjB,GAAIvI,KAAgC,IAAhB6N,IAA0C,IAAjBtF,GAE3C,YADAjP,EAAUwE,GAKZ,GAAIwN,EAASzH,yBAA2ByH,EAASxH,wBAAyB,CAAA,IAAAgK,EACxExC,EAAS/G,YAAYvD,GACrBsK,EAASzH,yBAA0B,EACnCyH,EAASxH,yBAA0B,EACnC,IAAQ7F,EAAcqN,EAAdrN,IAAKuG,EAAS8G,EAAT9G,KAGb,OAFmD,QAAnDsJ,EAACxC,EAASzH,wBAA0BgE,GAASI,UAAM,IAAA6F,GAAnDA,EAAuD,CAAE3V,EAAAA,EAAGqM,KAAAA,EAAMvG,IAAAA,EAAKxE,OAAQ,EAAGC,MAAO,SACzF8L,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAAA,EAAMvG,IAAAA,EAAKxE,OAAQ,EAAGC,MAAO,IAE7C,CAGA,IAAyB,IAArBiM,IACc,IAAhB2C,KACgB,IAAhBuF,IACkB,MAAjBD,IACEpQ,EAAKlB,SAASsR,IACnB,CAAA,IAAAG,EACQC,EAAc1C,EAAS9G,MAAQ8G,EAASnO,KACxC8Q,EAAoHF,QAA3FA,EAAGpI,aAAAA,EAAAA,EAAmB,CAAE3I,KAAAA,EAAMc,MAAAA,EAAON,KAAAA,EAAMyE,KAAMqJ,EAAS9G,KAAMtC,MAAOoJ,EAAS7R,MAAOtB,EAAAA,WAAI4V,IAAAA,EAAAA,EAAIC,EACxHE,EAAsBhW,EAAQ+V,GAEpCE,EAAsBD,GACtB5U,EAAU4U,EACZ,EAGyB,IAArBvI,IACc,IAAhB2C,KACgB,IAAhBuF,GACkB,MAAjBD,GAA0BpQ,EAAKlB,SAASsR,IACzCO,EAAsBnN,GAGxB,SAASmN,EAAsBnN,GAC7B,GAAIoH,GAAoB,CACtB,IAAMgG,EAAcpR,EAAKqR,WAAU,SAAApR,GAAI,OAAIA,IAAS+D,KAChDoN,GAAe,IACjB9C,EAAS7G,oBAAoB2J,GAC7B5I,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAM,KAAMvG,IAAKqN,EAASrN,IAAKxE,OAAQ,EAAGC,KAAM4R,EAAS5R,OACvE4O,IAAc,EAElB,MACEgD,EAAS/G,YAAYvD,GACrBwE,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAM,KAAMvG,IAAKqN,EAASrN,IAAKxE,OAAQ,EAAGC,KAAM4R,EAAS5R,OACvE4O,IAAc,CAElB,CACF,IAjJAE,GAAcjN,KAAKiC,EAAM,YAmJzB,SAA6BrF,GAE3B,GAAImW,EACF,OAAOA,GAA2B,EAEpChW,GAAK,WAEH,IAAMiW,EAASxW,IACTyW,GAAiBhR,EAAKlB,SAASiS,GAC/BE,EAAgBF,IAAWzQ,EAGjC,GAAI3F,EAAE6I,SAAWlD,GAAS0Q,EACxBjG,IAAe,MADjB,CAKA,IAAImG,EAAY,MACZD,GAAiBD,KACnBE,EAAYC,EAAmBxW,GAC3BiQ,GAAoBkD,EAAS7G,qBAAqB,GACjD6G,EAAS/G,YAAY,QAEV,IAAdmK,IAEAD,EACFnG,IAAc,EACLkG,IACTlG,IAAc,EACdC,IAAe,GAdjB,CAgBF,GACF,IAjLK/K,EAAKlB,SAASwB,IAAmB,MAATA,IAE3B0K,GAAcjN,KAAKuC,EAAO,SAgU5B,WAAmCyK,IAAe,CAAO,IA9TvDC,GAAcjN,KAAKuC,EAAO,QAgU5B,WACM8Q,EACFA,GAAmB,EAEnBrG,IAAe,CACnB,KAlUAC,GAAcjN,KAAKiC,EAAM,WAAW,SAAArF,GAClC,IAAI0W,GAAS,EAETjP,IACFiP,EA+aJ,SAA4B1W,GAC1B,GAAIA,EAAE6I,SAAWlD,EAAO,OAExB,GAAIoK,IAAetP,EAAcT,GAAI,OAErC,IAAK,IAAIuD,EAAI,EAAGA,EAAI0D,EAASzD,SAAWD,EAAG,CAEzC,GADaoT,EAAe3W,EAAGiH,EAAS1D,IAC9B,OAAO,CACnB,CACF,CAxbaqT,CAAmB5W,IAEzB0W,GACHtC,EAAmBpU,EACvB,IAEAqQ,GAAcjN,KAAKiC,EAAM,SAAS,SAAArF,IAuLlC,SAA8BA,GAE5B,IAAM6I,EAAS7I,EAAE6I,OAEjB,GAAIoH,GAAoB,CAEtB,IAAMgG,EAAcpR,EAAKqR,WAAU,SAAApR,GAAI,OAAIA,EAAKX,SAAS0E,MACzD,GAAIoN,GAAe,EAAG,CACpB,IAAcY,EAAuE1D,EAA7E9G,KAA+ByK,EAA8C3D,EAArD7R,MAAgCyV,EAAqB5D,EAA3B5R,KAC1D4R,EAAS7G,oBAAoB2J,GAE7B,IAAM5J,EAA2B8G,EAA3B9G,KAAM/K,EAAqB6R,EAArB7R,MAAOwE,EAAcqN,EAAdrN,IAAKvE,EAAS4R,EAAT5R,KACpBwV,EAAmB,GACjBD,IAAsBb,IACxB5J,EAAOwK,EACPvV,EAAQwV,GAIZ1J,SAAAA,EAAU,CAAEpN,EAAAA,EAAGqM,KAAAA,EAAMvG,IAAAA,EAAKxE,MAAAA,EAAOC,KAAAA,IAC7BwV,IAAqBxV,IACvB8L,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAAA,EAAMvG,IAAAA,EAAKxE,MAAAA,EAAOC,KAAAA,IACpC,CACF,KAAO,CAEL,IAAcsV,EAA2C1D,EAAjD9G,KAA6B2K,EAAoB7D,EAAzBrN,IAChCqN,EAAS/G,YAAYvD,GAErB,IAAMwD,EAAc8G,EAAd9G,KAAMvG,EAAQqN,EAARrN,IACW,MAAnBkR,GACEH,IAAqBhO,IACvBwD,EAAOwK,GAIXzJ,SAAAA,EAAU,CAAEpN,EAAAA,EAAGqM,KAAAA,EAAMvG,IAAAA,EAAKxE,OAAQ,EAAGC,MAAO,IACxCyV,IAAoBlR,IACtBuH,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAAA,EAAMvG,IAAAA,EAAKxE,OAAQ,EAAGC,MAAO,IAC/C,CACF,CA5NE0V,CAAqBjX,GAErBuH,GAwYF,SAA8BvH,GAC5B,IAAK,IAAIuD,EAAI,EAAGA,EAAI2D,EAAW1D,SAAWD,EAAG,CAE3C,GADa2T,EAAiBlX,EAAGkH,EAAW3D,IAClC,KACZ,CACF,CA7YmB4T,CAAqBnX,EACxC,IAGAqQ,GAAcjN,KAAKiC,EAAM,aA0JzB,SAAkCrF,GAIhC,IAAIoX,EAHJ1B,GAAc,EACdvV,GAAK,WAAA,OAAMuV,GAAc,CAAK,MAGzBzF,IACFA,KACEmH,EAAavS,EAAKwS,MAAK,SAAAvS,GAAI,OAAIA,EAAKX,SAASnE,EAAE6I,OAAO,QAGzDsH,IAAc,EACVtI,KAAcuI,IAAe,GAE7BhC,IAAoCgJ,QAAgC3O,IAAlB6O,OAAOC,SAC3DzW,EAAMsW,GACNpX,EAAEuI,kBAGR,IA1KIf,GAEF6I,GAAcjN,KAAKiC,EAAM,WA8Y3B,SAA8BrF,GAE5B,IAAK,IAAIuD,EAAI,EAAGA,EAAI4D,EAAW3D,SAAWD,EAAG,CAE3C,GADaiU,EAAiBxX,EAAGmH,EAAW5D,IAClC,KACZ,CACF,IAhZAgS,EAA2B/K,SAAQ,SAAAiN,GAAqB,IAAnB1W,EAAI0W,EAAA,GAAEpN,EAAOoN,EAAA,GAChDpH,GAAcjN,KAAKrC,EAAM,QAASsJ,EACpC,IACAgL,EAA2B7K,SAAQ,SAAAkN,GAAqB,IAAnB3W,EAAI2W,EAAA,GAAErN,EAAOqN,EAAA,GAChDrH,GAAcjN,KAAKrC,EAAM,QAASsJ,EACpC,IAEa,MAAT1E,GAEF0K,GAAcjN,KAAKuC,EAAO,WAkS5B,SAAyB3F,GACvB,GAAIA,EAAE6I,SAAWlD,EAAO,OACxB,IAAMyK,IAAiBD,GAAc,OAGrC,IAAIpB,SAAAA,GAAiBzO,GAAcN,KAAOmQ,GAcxC,OAbAnQ,EAAEuI,iBACFkO,GAAmB,EACnBtG,IAAc,EACdlB,UAAAA,GAAejP,QACXiQ,IACFkD,EAAS7G,oBAAoBoI,KAAKC,IAAI,EAAGxB,EAAS7R,QAClDR,EAAMqS,EAASrN,KACfuH,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAM,KAAMvG,IAAKqN,EAASrN,IAAKxE,OAAQ,EAAGC,KAAM4R,EAAS5R,SAEvE4R,EAAS/G,YAA6B,MAAjB+G,EAAS9G,KAAe8G,EAASnO,KAAOmO,EAAS9G,MACtEvL,EAAMqS,EAASrN,KACfuH,SAAAA,EAAS,CAAErN,EAAAA,EAAGqM,KAAM,KAAMvG,IAAKqN,EAASrN,IAAKxE,OAAQ,EAAGC,MAAO,MAMnE,IAAK,IAAIgC,EAAI,EAAGA,EAAI6L,GAAW5L,SAAWD,EAAG,CAC3C,IAAAoU,EAAoCvI,GAAW7L,GAAvChD,EAAGoX,EAAHpX,IAAKqI,EAAE+O,EAAF/O,GAAYgP,EAAMD,EAAd9O,OACXA,EAAS9I,EAAQ6X,GACvB,GAAIxW,EAAUb,EAAKP,EAAGmT,EAAS7R,MAAO6R,EAAS5R,MAE7C,YADAsW,EAAiB7X,EAAG4I,EAAIC,EAG5B,CAGA,GAAIyG,IACF3O,EAAaX,GAGb,OAFAkU,GAA4B,OAC5BpT,EAAMmE,GAKR,SAAS4S,EAAiB7X,EAAGwO,EAAQ3F,GACnC2F,SAAAA,EAASxO,GACT6I,GAAU/H,EAAM+H,GAChBkJ,IACF,CACF,IA3UA,IAAIoE,GAA2B,EAG3B7O,GACFoH,GAAQlE,SAAQ,SAAAsN,GACdzH,GAAcjN,KAAK0U,EAAQ,aAAa,SAAAtE,GAAC,OAAI2C,GAA2B,IAC1E,IAIF9F,GAAc9F,eAId,IAAImL,GAAc,EAEde,GAAmB,EAkUvB,SAASD,EAAmBxW,GAC1B,IAAK,IAAIuD,EAAI,EAAGA,EAAI+D,EAAa9D,SAAWD,EAAG,CAC7C,IAAAwU,EAA8EzQ,EAAa/D,GAAnFqF,EAAEmP,EAAFnP,GAAY8J,EAAaqF,EAArBlP,OAAuBL,EAAKuP,EAALvP,MAAOD,EAAcwP,EAAdxP,eAAgByF,EAAe+J,EAAf/J,gBAE1D,OAAO8D,GAAY9R,EAAG4I,EADP7I,EAAQ2S,GACWlK,EAAO7C,EAAOd,EAAMQ,EAAMiC,EAAa/D,GAAE,GAAKgF,EAAgByF,EAClG,CACF,CAEA,SAASgK,EAAyBhY,EAAG2H,EAAMsQ,GACzC,IAAczF,EAAmF7K,EAAzF5G,KAAmB6H,EAAsEjB,EAAtEiB,GAAY8J,EAA0D/K,EAAlEkB,OAAuBL,EAA2Cb,EAA3Ca,MAAOD,EAAoCZ,EAApCY,eAAgByF,EAAoBrG,EAApBqG,gBAC/DnJ,EAAqBsO,EAA3B5H,KAAYvG,EAAemO,EAAfnO,KAAMC,EAASkO,EAATlO,KACpBiT,EAAexY,EAAM8S,GAAeA,EAAY,CAAE3N,KAAAA,EAAMG,KAAAA,EAAMC,KAAAA,IAAUuN,EACxEzR,EAAOhB,EAAQmY,GACfrP,EAAS9I,EAAQ2S,GAEvB,OAAIuF,EAAUjY,EAAGe,EAAM4G,EAAKpH,OAGb,IADHuR,GAAY9R,EAAG4I,EAAIC,EAAQL,EAAO7C,EAAOd,EAAMQ,EAAMsC,KAASY,EAAgByF,EAE5F,CAEA,SAASkJ,EAAiBlX,EAAG2H,GAG3B,OAAOqQ,EAAyBhY,EAAG2H,GADjB,SAAC3H,EAAGe,GAAI,OAAc,MAARA,IAAiBA,EAAKoD,SAASnE,EAAE6I,SAAoB,MAAR9H,CAAY,GAE3F,CAUA,SAASyW,EAAiBxX,EAAG2H,GAG3B,OAAOqQ,EAAyBhY,EAAG2H,GADjB,SAAC3H,EAAGe,GAAI,OAAc,MAARA,GAAgBf,EAAE6I,SAAW9H,GAAiB,MAARA,CAAY,GAEpF,CAWA,SAAS4V,EAAe3W,EAAG2H,GAGzB,OAAOqQ,EAAyBhY,EAAG2H,GADnB,SAAC3H,EAAGe,EAAMR,GAAG,OAAc,MAARQ,GAAgBf,EAAE6I,SAAW9H,IAAWK,EAAUb,EAAKP,EAAGmT,EAAS7R,MAAO6R,EAAS5R,KAAM,GAE9H,CAcA,SAAS+T,EAA0B3N,GACjC,OAAO,SAAS3H,GAAKkX,EAAiBlX,EAAG2H,GAC3C,CAEA,SAAS6N,EAA0B7N,GACjC,OAAO,SAAS3H,GAAKwX,EAAiBxX,EAAG2H,GAC3C,CAMF,CAhfAsK,EARoC,CAyftC,CAGA,SAASzB,KAEP,GAAKF,GAAenG,QAApB,CAEA,IAFoC,IAAAgO,EAAAA,WAGlC,IAAMhL,EAAQkB,GAAQ9K,GACRqU,EAAkFzK,EAAxFpM,KAAc6H,EAA0EuE,EAA1EvE,GAAIrI,EAAsE4M,EAAtE5M,IAAKsG,EAAiEsG,EAAjEtG,KAAMgC,EAA2DsE,EAA3DtE,OAAQL,EAAmD2E,EAAnD3E,MAAOgG,EAA4CrB,EAA5CqB,OAAQjG,EAAoC4E,EAApC5E,eAAgByF,EAAoBb,EAApBa,gBACtE0F,EAAKvG,EAAQ,GACbiL,EAAQ,GAAG5V,OAAOqE,GAClBwR,EAAW,CAAC,UAAW,QAAS,SAChCtX,EAAOhB,EAAQ6X,GAErBQ,EAAM5N,SAAQ,SAAA3D,GACZ,GAAI9F,GAAQsX,EAAStR,SAASF,GAAO,CAGnC,IAEMyR,EAFiB,YAATzR,EAEQ,SAAA7G,GAAC,OAAIoB,EAAUb,EAAKP,EAAG6E,GAAKvD,MAAOuD,GAAKtD,KAAK,EAAG,SAAAiS,GAAC,OAAI,CAAI,EAC/ElD,GAAelN,KAAKrC,EAAM8F,EAI9B,SAAuByR,GACrB,OAAO,SAAAtY,GAEFN,EAAMgU,KACHA,EAAG,CAAE1T,EAAAA,EAAGqM,KAAMxH,GAAKwH,KAAMvG,IAAKjB,GAAKiB,IAAKxE,MAAOuD,GAAKvD,MAAOC,KAAMsD,GAAKtD,SAE1E+W,EAAMtY,IAKZ,SAA4BA,GAE1B,GAAImQ,IACF,GAAIzQ,EAAM8O,GAAS,CACjB,IAAA+J,EAA8BjT,EAAYsH,EAAUC,EAAUiC,GAAW1J,IAAjEP,EAAI0T,EAAJ1T,KAAMc,EAAK4S,EAAL5S,MAAON,EAAIkT,EAAJlT,KACrByM,GAAY9R,EAAGwO,EAAQ3F,GAAQ,EAAOlD,EAAOd,EAAMQ,EAAM,KAAMkD,EAAgByF,EACjF,OAGAkD,GAAalR,EAAG4I,EAAIC,EAAQL,EAAOD,EAAgByF,GAC/CJ,IAA6BM,IAC/BoC,GAAe1F,iBAErB,CAjBM4N,CAAmBxY,GAEzB,CAboCyY,CAAcH,GAChD,CACF,KAjBO/U,EAAI,EAAGA,EAAI8K,GAAQ7K,SAAWD,EAAC4U,IA+CxC7H,GAAe/F,cAjDc,CAkD/B,CAGA,SAASwH,KAGHzC,IAEA3B,IAA4BO,IAC9BmC,GAAczF,iBAElB,CACF"}