{"version":3,"file":"focus-no-jutsu.umd.min.js","sources":["../utils.js","../index.js"],"sourcesContent":["/** Object.prototype.toString.call 快捷方式 */\nexport const objToStr = obj => Object.prototype.toString.call(obj);\n\n/** 参数是否是对象 */\nexport const isObj = obj => objToStr(obj) === \"[object Object]\";\n\n/** 是否为函数 */\nexport const isFun = fun => objToStr(fun) === \"[object Function]\";\n\n/** document.activeElement 的快捷方式 */\nexport const getActiveElement = () => document.activeElement;\n\n/** document.querySelector 的快捷方式 */\nexport const querySelector = str => document.querySelector(str);\n\n/** 通过字符串查找节点，或者直接返回节点 */\nexport const element = e => typeof e === \"string\" ? querySelector(e) : e;\n\n/** 滴答 */\nexport const tick = function(fn) {\n  setTimeout(fn, 0);\n};\n\n/** 是否是 input 可 select 的元素 */\nexport const isSelectableInput = function(node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n};\n\n/** 是否按下了 enter */\nexport const isEnterEvent = function(e) {\n  return e.key === \"Enter\" || e.keyCode === 13;\n};\n\n/** 按键是否是 esc */\nexport const isEscapeEvent = function (e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\n/** 按键是否是 tab */\nexport const isTabEvent = function(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\n/** 是否是向前的 tab */\nexport const isTabForward = function(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n/** 是否是向后的 tab */\nexport const isTabBackward = function(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\n\n/** 找到两个元素的最小公共祖先元素 */\nexport const findLowestCommonAncestorNode = function(x, y) {\n  if (x == null || y == null) return null;\n  if (x.contains(y)) return x;\n  if (y.contains(x)) return y;\n\n  const range = new Range();\n  range.setStartBefore(x);\n  range.setEndAfter(y);\n  if (range.collapsed) {\n     range.setStartBefore(y);\n     range.setEndAfter(x);\n  }\n  return range.commonAncestorContainer;\n};","import { objToStr, isObj, isFun, getActiveElement, element, tick, isSelectableInput, isEnterEvent, isEscapeEvent, isTabForward, isTabBackward, findLowestCommonAncestorNode } from \"./utils\";\n\n/** 聚焦，如果是 input，则聚焦后选中 */\nconst focus = function(e) {\n  e.focus();\n  if (isSelectableInput(e))\n    e.select();\n};\n\n/** 尝试聚焦，如果聚焦失效，则下个 setTimeout 再次聚焦 */\nconst tickFocus = function(e) {\n  if (e == null) tick(() => e && focus(e));\n  else focus(e);\n};\n\n/** 手动聚焦下一个元素 */\nconst focusNextListItemBySequence = (subNodes, useActiveIndex, isClamp, isNext, isPrev, onNext, onPrev, coverNode, onMove, trappedList) => e => {\n  if (e.target === coverNode) return;\n  if (!trappedList()) return;\n\n  const [index_, setIndex] = useActiveIndex();\n  const index = Math.max(0, index_);\n  const itemsLen = subNodes.length;\n  if ((isNext ?? isTabForward)(e)) {\n    const incresedI = index + 1;\n    let nextI = isClamp ? Math.min(itemsLen - 1, incresedI) : incresedI;\n    nextI %= itemsLen;\n    onNext?.({ e, prev: subNodes[index], cur: subNodes[nextI], prevI: index, curI: nextI });\n    onMove?.({ e, prev: subNodes[index], cur: subNodes[nextI], prevI: index, curI: nextI });\n    setIndex(nextI);\n    focus(subNodes[nextI]);\n    e.preventDefault();\n  }\n  else if ((isPrev ?? isTabBackward)(e)) {\n    const decresedI = index - 1;\n    let nextI = isClamp ? Math.max(0, decresedI) : decresedI;\n    nextI = (nextI + itemsLen) % itemsLen;\n    onPrev?.({ e, prev: subNodes[index], cur: subNodes[nextI], prevI: index, curI: nextI });\n    onMove?.({ e, prev: subNodes[index], cur: subNodes[nextI], prevI: index, curI: nextI });\n    setIndex(nextI);\n    focus(subNodes[nextI]);\n    e.preventDefault();\n  }\n};\n\n/** 按下 tab，以浏览器的行为聚焦下个元素 */\nconst focusNextListItemByRange = (list, isClamp, onNext, onPrev, rootNode, coverNode, trappedList) => e => {\n  const head = list[0];\n  const tail = list.at(-1);\n  const current = e.target;\n  if (current === coverNode) return;\n  if (!trappedList()) return;\n\n  if (isTabForward(e)) {\n    onNext?.({ e });\n    if (current === tail) {\n      e.preventDefault();\n      if (!isClamp) focus(head);\n    }\n    if (current === rootNode) {\n      e.preventDefault();\n      focus(head)\n    }\n  }\n  else if (isTabBackward(e)) {\n    onPrev?.({ e });\n    if (current === head) {\n      e.preventDefault();\n      if (!isClamp) focus(tail);\n    }\n    if (current === rootNode) {\n      e.preventDefault();\n      focus(tail);\n    }\n  }\n};\n\n/** 获取关键节点 */\nconst getKeyNodes = function(originRoot, originList, originCover, coverIsRoot) {\n  const list = originList.map(item => element(item)).filter(item => item != null);\n  const head = list[0];\n  const tail = list.slice(-1)[0];\n  const root = element(originRoot) ?? findLowestCommonAncestorNode(head, tail);\n  const cover = coverIsRoot ? root : element(originCover);\n\n  return {\n    root,\n    list,\n    head,\n    tail,\n    cover,\n  };\n};\n\n/** 用于处理节点属性可以传递数组的情况，用于入口和出口 */\nconst pickNodesAry = function(acc, cur) {\n  const isAryNodes = Array.isArray(cur.node);\n  const nodes = isAryNodes ? cur.node.map(n => ({\n    ...cur,\n    node: n,\n  })) : cur;\n  return acc.concat(nodes);\n};\n\n/** 获取分割的出口 */\nconst splitExits = function(exits, root) {\n  /** 生效的节点是否在根元素内部（列表中） */\n  const isInnerRoot = node => (node != null && root.contains(element(node))) || node == null;\n\n  const [keyExits, clickExits, focusExits, clickExits_wild, focusExits_wild, outListExits] = exits.reduce((acc, e) => {\n    let [key, click, focus, click_wild, focus_wild, outList] = acc;\n    const includeType = type => e.type?.includes(type);\n    if (isInnerRoot(e.node)) {\n      if (includeType(\"keydown\")) key = key.concat(e);\n      if (includeType(\"click\")) click = click.concat(e);\n      if (includeType(\"focus\")) focus = focus.concat(e);\n      if (includeType(\"outlist\")) outList = outList.concat(e);\n    } else {\n      if (includeType(\"click\")) click_wild = click_wild.concat(e);\n      if (includeType(\"focus\")) focus_wild = focus_wild.concat(e);\n      if (includeType(\"outlist\")) outList = outList.concat(e);\n    }\n    return [key, click, focus, click_wild, focus_wild, outList];\n  }, new Array(6).fill([]));\n\n  const hasClickExits = clickExits.length > 0;\n  const hasFocusExits = focusExits.length > 0;\n  const hasKeyExits = keyExits.length > 0;\n  \n  return {\n    keyExits, clickExits, focusExits, hasClickExits, hasFocusExits, hasKeyExits,\n    clickExits_wild, focusExits_wild,\n    outListExits,\n  };\n}\n\n/** 获取（生成）出口 */\nconst getExits = function(exit, onEscape, enabledCover, cover, trigger) {\n\n  let tempExits = [].concat(exit).filter(o => o != null)\n    .map(ele => isObj(ele) ? ele : { node: ele })\n    .map(e => ({\n      ...e,\n      // undefined 表示用户没有主动设置\n      type: e.type === undefined ? [e.key == null ? '' : \"keydown\", e.node == null ? '' : \"click\"].filter(t => t !== '') : [].concat(e.type),\n    }))\n    .reduce(pickNodesAry, []);\n  let _onEscape = isFun(onEscape) ? onEscape : onEscape === true ? tempExits[0]?.on ?? (() => {}) : onEscape;\n  /** 按下 esc 的出口 */\n  const escapeExit = isFun(_onEscape) ? {\n    node: null,\n    key: isEscapeEvent,\n    on: _onEscape,\n    target: enabledCover ? cover : trigger,\n    type: [\"keydown\"],\n  } : null;\n  const exits = [escapeExit].concat(tempExits).filter(e => e != null);\n\n  return exits;\n};\n\n/** 获取聚焦或失焦时延迟的类型 */\nconst getDelayType = function(delay, processor) {\n  const isFunctionDelay = isFun(delay);\n  const delayRes = isFunctionDelay && delay(processor);\n  const promiseDelay = isFunctionDelay && objToStr(delayRes) === \"[object Promise]\" && typeof delayRes.then === \"function\";\n  const callbackDelay = isFunctionDelay && !promiseDelay;\n  const commonDelay = (delay === true) && !promiseDelay && !callbackDelay;\n  return {\n    promiseDelay,\n    callbackDelay,\n    commonDelay,\n    delayRes,\n  };\n};\n\n/** 延迟执行某些操作 */\nconst delayToProcess = function(delay, processor) {\n\n  const { promiseDelay, callbackDelay, commonDelay, delayRes } = !!delay ? getDelayType(delay, processor) : {};\n  if (promiseDelay) delayRes.then(processor);\n  else if (callbackDelay) {}\n  else if (commonDelay) processor();\n  else return true;\n};\n\n/** 获取出口或者入口的目标 */\nconst getTarget = function(target, cover, list, root, enabledCover, activeIndex, defaultTarget, e) {\n  // 空 target 走默认\n  if (target == null || target === true) {\n    if (enabledCover) return cover;\n    else return defaultTarget;\n  }\n  // 函数 target 则传入节点执行\n  else if (isFun(target)) {\n    const gotTarget = target({ e, list, cover, root, last: list[activeIndex], lastI: activeIndex });\n    if (gotTarget == null || gotTarget === true) {\n      if (enabledCover) return cover;\n      else return defaultTarget;\n    }\n    return gotTarget;\n  }\n  // 选择器字符串或者节点，则直接获取\n  else return element(target);\n};\n\n/** 保存的监听事件信息，方便监听和移除监听 */\nclass ListenersCache {\n  cache = [];\n  isEmpty = true;\n  push(node, type, handler) {\n    this.isEmpty = false;\n    this.cache.push({\n      node,\n      type,\n      handler,\n    });\n  }\n  clean() {\n    this.cache = [];\n    this.isEmpty = true;\n  }\n  addListeners() {\n    this.cache.forEach(l => l.node?.addEventListener(l.type, l.handler));\n  }\n  removeListeners() {\n    this.cache.forEach(l => l.node?.removeEventListener(l.type, l.handler));\n    this.clean();\n  }\n}\n\n/** 按键转发的缓存 */\nclass KeyForwardCache {\n  cache = new Map();\n  has(id) {\n    return this.cache.has(id);\n  }\n  push(id, node, handler) {\n    if (this.has(id)) return;\n    node.addEventListener(\"keydown\", handler);\n    this.cache.set(id, {\n      node,\n      handler,\n    })\n  }\n  remove(id) {\n    const ids = [].concat(id);\n    ids.forEach(id => this.cache.get(id).node.removeEventListener(\"keydown\", this.cache.get(id).handler));\n  }\n}\n\n/** 保存列表数据 */\nclass TabList {\n  data = [];\n  head = null;\n  tail = null;\n  prevI = -1;\n  curI = -1;\n  _prev = null;\n  _cur = null;\n  get prev() {\n    return this._prev || this.data[this.prevI] || null; // _prev 可能由于 dom 未加载而为 null，为 null 则通过 prevI 取值\n  };\n  get cur() {\n    return this._cur || this.data[this.curI] || null;\n  };\n  set prev(v) {\n    this._prev = v;\n  };\n  set cur(v) {\n    this._cur = v;\n  };\n  update(list) {\n    this.data.splice(0, this.data.length);\n    Array.prototype.push.apply(this.data, list);\n    this.head = list[0];\n    this.tail = list.at(-1);\n  };\n  isEmpty() {\n    return this.data.length === 0;\n  };\n  has(i) {\n    return !!this.data[i];\n  };\n  record(cur, curI) {\n    if (this.curI === curI // this.curI 和 curI 必须不同\n      || (this.curI < 0 && curI < 0)) // curI 为 -1 后，不会再次更新新的 -1\n      return;\n    this.recordPrev(this.cur, this.curI);\n    this.recordCur(cur, curI);\n  };\n  recordPrev(prev, prevI) {\n    this.prevI = prevI < 0 ? -1 : prevI;\n    this.prev = prev || null;\n  };\n  recordCur(cur, curI) {\n    this.curI = curI < 0 ? -1 : curI;\n    this.cur = cur || null;\n  };\n  recordSequenceByIdx(curI) {\n    this.record(this.data[curI], curI);\n  };\n}\n\nconst focusNoJutsu = (...props) => {\n  const offset = 0 - (props[0] instanceof Array);\n  const rootNode = props[0 + offset];\n  const subNodes = props[1 + offset];\n  const options  = props[2 + offset] ?? {};\n\n  if (!(Array.isArray(subNodes) && subNodes.length > 1))\n    throw new Error(\"请至少传入一个数组，数组至少包含两个可聚焦元素，用来表示列表的头和尾。\");\n\n  const {\n    /** move: tab 序列，指定可以聚焦的元素，聚焦 list 内的元素 */\n    sequence,\n    /** move: 是否循环，设置后，尾元素的下个焦点是头元素，头元素的上个焦点是尾元素 */\n    loop,\n    /** move: 自定义前进焦点函数 */\n    next,\n    /** move: 自定义后退焦点函数 */\n    prev,\n    /** focus/blur: 触发器，如果使用 focusNoJutsu.enter 则不用设置，如果使用 entry.selector 则不用设置 */\n    trigger,\n    /** focus: 触发触发器的配置 */\n    entry,\n    /** blur: 触发退出触发器的配置 */\n    exit,\n    /** blur: 按下 esc 的行为，如果未设置，则取 exit.on */\n    onEscape,\n    /** 点击列表单项的响应，行为 */\n    onClick,\n    /** 移动的时候触发 */\n    onMove,\n    /** cover: 封面，默认情况，触发入口后首先聚焦封面，而不是子元素 */\n    cover,\n    /** 初始的列表中聚焦元素的序号 */\n    initialActive,\n    /** 矫正列表的焦点 */\n    correctionTarget,\n    /** 延迟挂载非触发器元素的事件，可以是一个返回 promise 的函数，可以是一个接收回调函数的函数 */\n    delayToFocus,\n    /** 延迟失焦，触发出口后等待执行 delayToBlur 完成后失焦 */\n    delayToBlur,\n    /** 每次退出列表回到入口是否移除列表事件 */\n    removeListenersEachExit = true,\n    /** 每次进入列表是否移除入口事件 */\n    removeListenersEachEnter,\n    /** 每次退出列表是否添加入口监听事件 */\n    addEntryListenersEachExit = true,\n    /** 手动添加和移除监听事件，入口、列表、出口的监听事件，`removeListenersEachExit` 和 `removeListenersEachEnter` 将失效 */\n    manual,\n    /** 用于抹平 Safari 不同于其它浏览器，点击后 button 之类的元素不会被聚焦的问题 */\n    allowSafariToFocusAfterMousedown = true,\n    /** 用于内部调试 */\n    // demo = false,\n  } = options;\n\n  /** 入口们 */\n  const entries = [].concat(entry) // 转为数组\n    .filter(o => o != null) // 过滤空值\n    .map(ele => isObj(ele) ? ele : { node: ele }) // 元素转为对象，并且默认元素的值被看作对象的 node 属性\n    .map(entry => ({ // 对元素的属性进行默认处理\n      ...entry,\n      delay: entry.delay ?? delayToFocus,\n      type: entry.type === undefined ? [entry.key == null ? '' : \"keydown\", entry.node == null ? '' : \"click\"].filter(t => t != '') : [].concat(entry.type),\n      onExit: entry.onExit === true ? entry.on : entry.onExit, // 这个入口是开关吗\n    }))\n    .reduce(pickNodesAry, []); // 处理元素的 node 属性是数组的情况，将它分解成多个元素\n  /** 是否是空入口 */\n  const hasNoEntry = entries.length === 0;\n  /** 带切换的入口，如果 entry.onExit 有值，代表这个入口同时也是出口，也就是开关 */\n  const toggles = new Set(entries.map(e => isFun(e.onExit) ? e.node : null).filter(n => n != null).map(n => element(n)));\n  /** 默认入口，默认情况下，会从出口回到这个入口 */\n  let _trigger = element(trigger || entries[0]?.node);\n\n\n  const {\n    /** 封面节点 */\n    node: coverNode,\n    enterKey: coverEnterKey,\n    onEnter: onEnterCover,\n    exit: exitCover,\n  } = isObj(cover) ? cover : {};\n  /** 是否已经打开封面选项 */\n  const enabledCover = cover != null && cover !== false && coverNode !== false;\n  /** 封面即根元素 */\n  const coverIsRoot = enabledCover && (cover === true || coverNode === true || coverNode == null);\n  /** 退出封面，封面的出口们 */\n  const exitsCover = [].concat(exitCover) // 转为数组\n    .filter(e => e != null) // 过滤空值\n    .map(e => isObj(e) ? e : { key: e }) // 元素转为对象，并且默认元素的值被看作对象的 key 属性\n    .map(e => ({ // 对元素的属性进行默认处理\n      ...e,\n      target: e.target ?? _trigger,\n    }));\n  /** 是否使用默认的离开封面方法，也即 tab 和 shift-tab */\n  const isDefaultExitCover = enabledCover && exitsCover.length === 0;\n\n\n  /** 列表 */\n  const list = new TabList();\n\n  list.recordPrev(null, initialActive ?? -1);\n\n  const {\n    key: isNext,\n    on: onNext,\n  } = isObj(next) ? next : { key: next };\n\n  const {\n    key: isPrev,\n    on: onPrev,\n  } = isObj(prev) ? prev : { key: prev };\n\n  /** 禁用左上角 esc 出口 */\n  const disabledEsc = onEscape === false;\n\n  /** 取消循环则设置头和尾焦点 */\n  const isClamp = !(loop ?? true);\n\n  /** 是否打开列表序列，按照序列的顺序进行焦点导航 */\n  const enabledTabSequence = !!(isNext || isPrev || sequence); // 自定义前进或后退焦点函数，则设置 sequence 为 true\n\n  /** 进入了列表 */\n  let trappedList = false;\n  /** 进入了封面 */\n  let trappedCover = false;\n\n  /** 是否已添加监听事件 */\n  const listListeners = new ListenersCache();\n  /** 是否已添加入口的监听事件 */\n  const entryListeners = new ListenersCache();\n  /** 按键转发，监听事件 */\n  const keyForwards = new KeyForwardCache();\n\n  if (!manual) { // 如果不是手动添加事件，则注册入口、列表相关（封面、列表、出口）的事件\n    // 入口点击事件\n    addEntryListeners();\n\n    // 如果有入口不需要延迟，则立即加载列表的监听事件\n    const hasImmediateEntry = (hasNoEntry ? [{}] : entries).some(({ delay }) => !delay);\n\n    if (hasImmediateEntry) {\n\n      const {\n        root, list: newList, cover,\n      } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n      list.update(newList);\n\n      loadListRelatedListeners(root, list, cover);\n    }\n  }\n\n  const Return = {\n    /** 调用形式的入口 */\n    enter(entry) {\n      _trigger = _trigger || getActiveElement();\n\n      if (entry) {\n        const { on, target, delay } = entry;\n        return entryHandler({ fromInvoke: true }, on, target, delay);\n      } else {\n        for (let i = 0; i < entries.length; ++ i) {\n          const { on, type, node, target, delay } = entries[i];\n          const invokeType = \"invoke\";\n\n          if (type?.some(type => type == null || type === false || type === invokeType) || node == null) {\n            return entryHandler({ fromInvoke: true }, on, target, delay);\n          }\n        }\n        return entryHandler({ fromInvoke: true });\n      }\n    },\n    /** 调用形式的出口 */\n    exit(tempExit) {\n\n      const {\n        list: newList,\n        cover,\n        root,\n      } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n\n      if (tempExit) {\n        const { on, target: originTarget } = tempExit;\n        const target = element(originTarget);\n        return toExit(target, on);\n      } else {\n        const exits = getExits(exit, onEscape, enabledCover, cover, _trigger);\n        for (let i = 0; i < exits.length; ++ i) {\n          const { on, type, target } = exits[i];\n          const invokeType = \"invoke\";\n  \n          if (type?.some(type => type == null || type === false || type === invokeType)) {\n            return toExit(target, on);\n          }\n        }\n      }\n\n      function toExit(target, on) {\n\n        if (list.isEmpty()) list.update(newList);\n\n        return exitHandler({ fromInvoke: true }, on, target, false, cover, list.data, root);\n      }\n    },\n    /** 移除所有的监听事件 */\n    removeListeners() {\n      listListeners.removeListeners();\n      entryListeners.removeListeners();\n    },\n    /** 移除列表相关的事件 */\n    removeListRelatedListeners() {\n      listListeners.removeListeners();\n    },\n    /** 移除入口事件 */\n    removeEntryListeners() {\n      entryListeners.removeListeners();\n    },\n    /** 添加入口的监听事件 */\n    addEntryListeners() {\n      addEntryListeners();\n    },\n    /** 添加列表相关（封面、列表、出口）的监听事件 */\n    addListRelatedListeners() {\n\n      const {\n        root,\n        list: newList,\n        cover,\n      } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n      if (list.isEmpty()) list.update(newList);\n\n      loadListRelatedListeners(root, list, cover);\n    },\n    /** 添加转发 */\n    addForward(id, forward) {\n      let opts = null;\n      if (isFun(forward)) {\n        const {\n          root,\n          list: listData, head, tail,\n          cover,\n        } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n\n        opts = forward({ root, list: listData, head, tail, cover, curI: list.curI, prevI: list.prevI });\n      }\n      else opts = forward;\n\n      const { node: origin_node, on, key, target: origin_target } = opts;\n      const node = element(origin_node);\n      const target = element(origin_target);\n      keyForwards.push(id, node, e => {\n        if (key?.(e, list.prevI, list.curI)) {\n          e.preventDefault();\n          on?.();\n          tickFocus(target);\n        }\n      });\n    },\n    /** 移除转发 */\n    removeForward(id) {\n      keyForwards.remove(id);\n    },\n    /** 更新列表 */\n    updateList(newList) {\n      const _newList = newList.map(item => element(item)).filter(item => item != null);\n      list.update(_newList);\n    },\n    /** 当前聚焦的列表单项序号 */\n    i(newI) {\n      if (list.has(newI) && trappedList) {\n        list.recordSequenceByIdx(newI);\n        const { prev, prevI, cur, curI } = list;\n        onMove?.({ e: { fromI: true }, prev, prevI, cur, curI });\n        focus(subNodes[curI]);\n        return newI;\n      }\n      else return list.curI < 0 ? list.prevI : list.curI;\n    },\n  };\n\n  return Return;\n\n  /** 入口 handler */\n  function entryHandler(e, onEnter, target, delay) {\n\n    // 如果已经在列表或者封面，则不再触发入口；出口不需要该操作，因为不存在从出口退出到出口的子元素的情况，相反，存在入口进入到入口子元素的情况。\n    if (trappedCover || trappedList) return;\n\n    Promise.resolve(onEnter?.(e)).then(_ => {\n      const isImmediate = !delay;\n      if (isImmediate) findNodesToLoadListenersAndFocus();\n      else delayToProcess(delay, findNodesToLoadListenersAndFocus);\n    })\n\n    /** 寻找节点，加载事件监听器，聚焦 subNodes 或 coverNode */\n    function findNodesToLoadListenersAndFocus() {\n      const {\n        root,\n        list: newList,\n        cover,\n      } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n      list.update(newList);\n\n      if (!manual)\n        loadListRelatedListeners(root, list, cover);\n      if (target !== false)\n        focusTarget(cover, list, root);\n    }\n    \n    function focusTarget(cover, listInfo, rootNode) {\n      const list = listInfo.data;\n      const { prev, head, curI } = listInfo;\n      const defaultTarget = prev || head;\n      const gotTarget = getTarget(target, cover, list, rootNode, enabledCover, curI, defaultTarget, e);\n      const targetIdx = list.indexOf(gotTarget);\n      if (targetIdx > -1) {\n        if (enabledTabSequence) { // onMove 仅支持打开 sequence 后\n          listInfo.recordSequenceByIdx(targetIdx); // 只有在聚焦列表元素时才设置，否则会破坏原有 curI\n          const { cur, curI } = listInfo;\n          onMove?.({ e, prev: null, cur, prevI: -1, curI });\n        }\n        trappedList = true;\n      }\n      if (enabledCover && (gotTarget === cover || targetIdx > -1)) trappedCover = true;\n      tickFocus(gotTarget);\n    }\n  }\n\n  /** 出口 handler */\n  function exitHandler(e, on, target, delay, cover, listData, root, ef) {\n\n    if (!trappedList || \n      !(isFun(ef) ? ef({ e, prev: list.prev, cur: list.cur, prevI: list.prevI, curI: list.curI }) : true))\n      return false;\n\n    list.recordSequenceByIdx(-1);\n\n    trappedList = false;\n\n    e.preventDefault?.(); // 阻止默认行为，例如 tab 到下一个元素，例如 entry button 触发 click 事件\n\n    const gotTarget = getTarget(target, cover, listData, root, enabledCover, list.curI, _trigger, e);\n\n    if (gotTarget) return exitListWithTarget();\n    else return exitListWithoutTarget();\n\n    /** 退出列表，有 target */\n    function exitListWithTarget() {\n\n      Promise.resolve(on?.(e)).then(_ => {\n        delay = delay ?? delayToBlur;\n        const isImmediate = delayToProcess(delay, focusThenRemoveListeners);\n        if (isImmediate) focusThenRemoveListeners();\n      });\n\n      function focusThenRemoveListeners() {\n        focus(gotTarget);\n        enabledTabSequence && onMove?.({ e, prev: list.prev, cur: null, prevI: list.prevI, curI: -1 });\n        if (!manual) {\n          if (gotTarget !== cover)\n            removeListRelatedListeners();\n          if (addEntryListenersEachExit)\n            addEntryListeners();\n        }\n      }\n    }\n\n    /** 退出列表，无 target */\n    function exitListWithoutTarget() {\n\n      Promise.resolve(on?.(e)).then(_ => {\n\n        if (gotTarget === false) { // 如果显式设为 false，则直接退出，不聚焦，会在一个列表退出另一个列表移动的场景使用\n\n          const removeListenersWithoutFocus = focusThenRemoveListeners();\n          removeListenersWithoutFocus();\n          return ;\n        }\n        if (enabledCover) {\n\n          enabledTabSequence && onMove?.({ e, prev: list.prev, cur: null, prevI: list.prevI, curI: -1 });\n          focus(cover);\n        } else {\n  \n          delay = delay ?? delayToBlur;\n          const focusTriggerThenRemoveListeners = focusThenRemoveListeners(_trigger);\n          const isImmediate = delayToProcess(delay, focusTriggerThenRemoveListeners);\n          if (isImmediate) focusTriggerThenRemoveListeners();\n        }\n      });\n\n      function focusThenRemoveListeners(focusTarget) {\n        return _ => {\n          focusTarget && focus(focusTarget);\n          enabledTabSequence && onMove?.({ e, prev: list.prev, cur: null, prevI: list.prevI, curI: -1 });\n          if (!manual) {\n            removeListRelatedListeners();\n            if (addEntryListenersEachExit)\n              addEntryListeners();\n          }\n        }\n      }\n    }\n  }\n\n  /** 生成事件行为，添加事件监听器 */\n  function loadListRelatedListeners(root, listInfo, cover) {\n\n    const list = listInfo.data;\n    const head = listInfo.head;\n    const tail = listInfo.tail;\n\n    if (!listListeners.isEmpty) return ; // 列表的监听事件没有移除之前，不需要再次添加列表监听事件\n\n    if (root == null)\n      throw new Error(`没有找到元素 ${rootNode}，您可以尝试 delayToFocus 选项，等待元素 ${rootNode} 渲染完毕后进行聚焦。`);\n    if (head == null || tail == null)\n      throw new Error(\"至少需要包含两个可以聚焦的元素，如果元素需要等待渲染，您可以尝试 delayToFocus 选项。\");\n\n    // 添加除 trigger 以外其它和焦点相关的事件监听器\n    addListRelatedListeners();\n\n    /** 添加焦点需要的事件监听器 */\n    function addListRelatedListeners() {\n\n      const useActiveIndex = () => [listInfo.curI, listInfo.recordSequenceByIdx.bind(listInfo)];\n\n      const isTrappedList = () => hasNoEntry ? true : trappedList;\n\n      // 在焦点循环中触发聚焦\n      const keyListMoveHandler = enabledTabSequence ?\n        focusNextListItemBySequence(list, useActiveIndex, isClamp, isNext, isPrev, onNext, onPrev, cover, onMove, isTrappedList) :\n        focusNextListItemByRange(list, isClamp, onNext, onPrev, root, cover, isTrappedList);\n\n      /** 出口们，列表的出口们，list 的出口们 */\n      const exits = getExits(exit, onEscape, enabledCover, cover, _trigger);\n      const {\n        keyExits, clickExits, focusExits, hasClickExits, hasFocusExits, hasKeyExits,\n        clickExits_wild, focusExits_wild,\n        outListExits,\n      } = splitExits(exits, root);\n\n      /** 非跟节点内的，是根节点之外的出口 */\n      const clickListExitHandlers_wild = clickExits_wild.map(exit => [element(exit?.node), clickListExitHandler_wild(exit)]);\n      const focusListExitHandlers_wild = focusExits_wild.map(exit => [element(exit?.node), focusListExitHandler_wild(exit)]);\n\n      listListeners.push(root, \"focusin\", focusTrapListHandler);\n\n      listListeners.push(root, \"focusout\", blurTrapListHandler);\n\n      if (!root.contains(cover) && cover != null) {\n\n        listListeners.push(cover, \"focus\", focusTrapCoverHandler);\n\n        listListeners.push(cover, \"blur\", blurTrapCoverHandler);\n      }\n\n      listListeners.push(root, \"keydown\", e => {\n        // 列表中移动，监听移动的键盘事件，例如 tab 或其它自定义组合键\n        keyListMoveHandler(e);\n        // 列表键盘出口\n        if (hasKeyExits) keyListExitHandler(e);\n      });\n\n      if (enabledTabSequence || hasClickExits) {\n        listListeners.push(root, \"click\", e => {\n          // 点击聚焦列表单项，只在手动列表时监听点击，因为自动模式不需要记录 list.curI\n          enabledTabSequence && clickListItemHandler(e);\n          // 列表点击出口\n          hasClickExits && clickListExitHandler(e);\n        });\n      }\n\n      // 由于 click 事件在 focus 之后，这里用来判断是否通过点击进入列表，用于纠错未知进入列表的焦点定位\n      listListeners.push(root, \"mousedown\", mousedownListItemHandler);\n\n      if (hasFocusExits) {\n        // 列表聚焦出口\n        listListeners.push(root, \"focusin\", focusListExitHandler);\n      }\n\n      // 非列表内的出口\n      focusListExitHandlers_wild.forEach(([node, handler]) => {\n        listListeners.push(node, \"focus\", handler);\n      });\n      clickListExitHandlers_wild.forEach(([node, handler]) => {\n        listListeners.push(node, \"click\", handler);\n      });\n\n      if (cover != null) {\n        // 封面的事件\n        listListeners.push(cover, \"keydown\", keyCoverHandler);\n      }\n\n      // flush\n      listListeners.addListeners();\n\n\n\n      let isMouseDown = false;\n      /** 标记是否从封面进入列表，用于防止纠正列表焦点的误判，用于野生封面 */\n      let isEnterFromCover = false;\n\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n       |          LIST HANDLERS          |\n       +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n\n      function focusTrapListHandler(e) {\n\n        // 进入封面（封面在列表中）\n        if (enabledCover && e.target === cover) { // TODO: 保留确认，或是否需要添加 `&& trappedList` 条件\n          trappedCover = true;\n          return ;\n        }\n\n        // 纠正进入封面，从外部进入列表，如果没有通过封面，则重新聚焦封面\n        if (enabledCover && isMouseDown === false && trappedCover === false) {\n          tickFocus(cover);\n          return ;\n        }\n\n        // 纠正外部聚焦进来的焦点\n        if (correctionTarget !== false && enabledTabSequence && trappedList === false && isMouseDown === false) // 如果是内部的聚焦，无需纠正，防止嵌套情况的循环问题\n        {\n          const defaultLast = listInfo.prev || listInfo.head;\n          const originGotCorrectionTarget = correctionTarget?.({ list, cover, root, last: listInfo.prev, lastI: listInfo.prevI }) ?? defaultLast;\n          const gotCorrectionTarget = element(originGotCorrectionTarget);\n          const targetIndex = list.findIndex(item => item === gotCorrectionTarget);\n          if (targetIndex > -1) {\n            listInfo.recordSequenceByIdx(targetIndex);\n            onMove?.({ e, prev: null, cur: listInfo.cur, prevI: -1, curI: listInfo.curI });\n          }\n\n          trappedList = true; // 在下一次 触发 focusin 调用 focusTrapListHandler 之前，设为 true。通过 api 调用的 focus，触发的 focusin 事件会被“同步”调用\n          tickFocus(gotCorrectionTarget);\n        }\n\n        trappedList = true; // 无论列表的类型是序列还是范围，被聚焦后都被定义为“已陷入列表”（这里主要用于范围列表模式）\n      }\n\n      function blurTrapListHandler(e) {\n        // 用于保护可切换的入口能够被触发\n        if (toggles.has(e.relatedTarget)) return;\n\n        tick(() => { // 延迟后获取下一次聚焦的元素，否则当前聚焦元素是 body\n\n          const active = getActiveElement();\n          const isOutRootNode = !root.contains(active);\n          const isActiveCover = active === cover;\n\n          // 从封面退出\n          if (e.target === cover && isOutRootNode) {\n            trappedCover = false; // 退出封面\n            return;\n          }\n\n          let isOutList = null;\n          if (isActiveCover || isOutRootNode) {\n            isOutList = outListExitHandler(e);\n            listInfo.recordSequenceByIdx(-1);\n          }\n          if (isOutList === false) return; // 不符合 outlist 退出列表的条件\n\n          if (isActiveCover) { // 聚焦在封面\n            trappedList = false;\n          } else if (isOutRootNode) { // 聚焦在非封面、非列表的区域\n            trappedList = false;\n            trappedCover = false;\n          }\n        });\n      }\n\n      function mousedownListItemHandler(e) {\n        isMouseDown = true;\n        tick(() => isMouseDown = false); // mousedown 没有出口，只能使用定时器，isMouseDown 主要在两个 focus 事件中使用，当触发 focus 时，此定时器还未执行，以此保证正确性\n\n        let targetItem;\n        if (!enabledTabSequence || // 未打开 sequence 属性 或者\n          (enabledTabSequence && // 已打开 sequence 属性 并且\n            (targetItem = list.find(item => item.contains(e.target))) // 点击的目标是列表中的元素\n          )\n        ) {\n          trappedList = true;\n          if (enabledCover) trappedCover = true;\n          // 兼容 Safari（桌面端），具体问题查看：https://github.com/wswmsword/web-experiences/tree/main/browser/safari-button-focus\n          if (allowSafariToFocusAfterMousedown && targetItem && window.safari !== undefined) {\n            focus(targetItem); // Safari 不会聚焦按钮元素，这里强制使用 api 聚焦\n            e.preventDefault(); // 阻止默认行为可以避免 targetItem 失焦\n          }\n        }\n      }\n\n      /** 点击聚焦列表某一单项 */\n      function clickListItemHandler(e) {\n        const targetIndex = list.findIndex(item => item.contains(e.target));\n        if (targetIndex > -1) {\n          const { prev: prevBeforeRecord, prevI: prevIBeforeRecord, curI: curIBeforeRecord } = listInfo;\n          listInfo.recordSequenceByIdx(targetIndex);\n\n          let { prev, prevI, cur, curI } = listInfo;\n          if (curIBeforeRecord < 0) { // 从外部进入\n            if (prevIBeforeRecord !== targetIndex) { // 上一次进入 和 本次进入 的元素不同\n              prev = prevBeforeRecord;\n              prevI = prevIBeforeRecord;\n            }\n          }\n\n          onClick?.({ e, prev, cur, prevI, curI });\n          if (curIBeforeRecord !== curI) // 从外部进入 或者 列表内的移动\n            onMove?.({ e, prev, cur, prevI, curI });\n        }\n      }\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n      |         COVER HANDLERS          |\n      +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n\n      function focusTrapCoverHandler() { trappedCover = true; } // 捕获点击封面的情况\n\n      function blurTrapCoverHandler() { // 捕获点击空白区域的情况\n        if (isEnterFromCover) // 用于防止纠正列表焦点的误判，如果是进入列表，则 trappedCover 还应是 true\n          isEnterFromCover = false;\n        else\n          trappedCover = false;\n      }\n\n      /** 封面的键盘事件响应 */\n      function keyCoverHandler(e) {\n        if (e.target !== cover) return;\n        if (!(trappedCover && !trappedList)) return; // 继续执行，必须满足焦点在封面上，且不在列表中\n\n        // 入口（封面），从封面进入列表\n        if((coverEnterKey ?? isEnterEvent)(e) && !trappedList) {\n          e.preventDefault();\n          isEnterFromCover = true;\n          trappedList = true;\n          onEnterCover?.(e);\n          if (enabledTabSequence) {\n            listInfo.recordSequenceByIdx(Math.max(0, listInfo.prevI));\n            focus(listInfo.cur);\n            onMove?.({ e, prev: null, cur: listInfo.cur, prevI: -1, curI: listInfo.curI });\n          } else\n            focus(listInfo.data[0]);\n          return;\n        }\n\n        // 出口（封面），从封面回到入口\n        for (let i = 0; i < exitsCover.length; ++ i) {\n          const { key, on, target: origin } = exitsCover[i];\n          const target = element(origin);\n          if (key?.(e, listInfo.prevI, listInfo.curI)) {\n            exitCoverHandler(e, on, target);\n            return;\n          }\n        }\n\n        // 默认出口，默认行为，默认的行为的场景是包含子元素的长列表\n        if (isDefaultExitCover &&\n          isTabForward(e)) { // 虽然也是离开列表，但是这里不移除监听事件，因为移除后就不能再次进入封面\n          focus(tail);\n          return;\n        }\n\n        /** 退出封面焦点的行为 */\n        function exitCoverHandler(e, onExit, target) {\n          onExit?.(e);\n          target && focus(target);\n          removeListRelatedListeners();\n        }\n      }\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n      |            + START +            |\n      |          EXIT HANDLERS          |\n      +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n\n      function outListExitHandler(e) {\n        for (let i = 0; i < outListExits.length; ++ i) {\n          const { on, target: origin_target, delay } = outListExits[i];\n          const target = element(origin_target);\n          return exitHandler(e, on, target, delay, cover, list, root, outListExits[i].if);\n        }\n      }\n\n      function exitHandlerWithCondition(e, exit, condition) {\n        const { node: origin_node, on, target: origin_target, delay } = exit;\n        const node = element(origin_node);\n        const target = element(origin_target);\n\n        if (condition(e, node, exit.key)) // 未设置点击目标\n          return false;\n        exitHandler(e, on, target, delay, cover, list, root, exit.if);\n        return true;\n      }\n\n      function clickExitHandler(e, exit) {\n\n        const cantClick = (e, node) => (node != null && !node.contains(e.target)) || node == null; // 点击目标不匹配 或者 未设置点击目标\n        return exitHandlerWithCondition(e, exit, cantClick);\n      }\n\n      /** 点击列表的出口 */\n      function clickListExitHandler(e) {\n        for (let i = 0; i < clickExits.length; ++ i) {\n          const isOK = clickExitHandler(e, clickExits[i]);\n          if (isOK) break; // 只生效第一个满足条件的出口\n        }\n      }\n\n      function focusExitHandler(e, exit) {\n\n        const cantFocus = (e, node) => (node != null && e.target !== node) || node == null; // 聚焦目标不匹配 或者 未设置点击目标\n        return exitHandlerWithCondition(e, exit, cantFocus);\n      }\n\n      /** 聚焦列表一个单项而退出 */\n      function focusListExitHandler(e) {\n\n        for (let i = 0; i < focusExits.length; ++ i) {\n          const isOK = focusExitHandler(e, focusExits[i])\n          if (isOK) break;\n        }\n      }\n\n      function keyExitHandler(e, exit) {\n\n        const cantKey = (e, node, key) => (node != null && e.target !== node) || (!key?.(e, listInfo.prevI, listInfo.curI)); // 聚焦目标不匹配 或者 未设置点击目标\n        return exitHandlerWithCondition(e, exit, cantKey);\n      }\n\n      /** 触发键盘退出列表，退出列表焦点 */\n      function keyListExitHandler(e) {\n        if (e.target === cover) return; // 被封面触发直接返回\n\n        if (disabledEsc && isEscapeEvent(e)) return;\n\n        for (let i = 0; i < keyExits.length; ++ i) {\n          const isOK = keyExitHandler(e, keyExits[i]);\n          if (isOK) break;\n        }\n      }\n\n      function clickListExitHandler_wild(exit) {\n        return function(e) { clickExitHandler(e, exit); }\n      }\n\n      function focusListExitHandler_wild(exit) {\n        return function(e) { focusExitHandler(e, exit); }\n      }\n\n      /*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~+\n      |             - END -             |\n      |          EXIT HANDLERS          |\n      +~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~*/\n    };\n  }\n\n  /** 添加入口事件 */\n  function addEntryListeners() {\n\n    if (!entryListeners.isEmpty) return;\n\n    for (let i = 0; i < entries.length; ++ i) {\n      const entry = entries[i];\n      const { node: origin, on, key, type, target, delay, onExit } = entry;\n      const ef = entry.if;\n      const types = [].concat(type);\n      const allTypes = [\"keydown\", \"focus\", \"click\"];\n      const node = element(origin);\n\n      types.forEach(type => {\n        if (node && allTypes.includes(type)) {\n\n          /** 是否是键盘事件 */\n          const isKey = type === \"keydown\";\n          /** 如果是键盘事件，则判断键位是否匹配，如果是非键盘事件，则直接返回 true */\n          const ifKey = isKey ? e => key?.(e, list.prevI, list.curI) : _ => true;\n          entryListeners.push(node, type, toggleHandler(ifKey, isKey)); // 保存事件信息\n        }\n      });\n      \n      function toggleHandler(ifKey, isKey) {\n        return e => {\n          if (\n            (isFun(ef)\n              ? ef({ e, prev: list.prev, cur: list.cur, prevI: list.prevI, curI: list.curI })\n              : true) &&\n            ifKey(e))\n            toggleEntryAndExit(e, isKey);\n        }\n      }\n\n      function toggleEntryAndExit(e, isKey) {\n\n        /** 是否执行 */\n        let processed = 0;\n        if (trappedList) {\n          if (isFun(onExit)) { // 若存在 onExit，则表示该入口同时是出口，是开关\n            const { list, cover, root } = getKeyNodes(rootNode, subNodes, coverNode, coverIsRoot);\n            exitHandler(e, onExit, target, false, cover, list, root);\n            processed = !processed;\n          }\n        }\n        else {\n          entryHandler(e, on, target, delay);\n          if (removeListenersEachEnter && !manual)\n            entryListeners.removeListeners();\n          processed = !processed;\n        }\n\n        // 如果是键盘事件，并且已执行，则阻止默认行为\n        if (isKey && processed) e.preventDefault();\n      }\n    }\n\n    // flush\n    entryListeners.addListeners();\n  }\n\n  /** 移除监听事件 */\n  function removeListRelatedListeners() {\n\n    // 如果是默认的，没有定义出口的封面，则不移除事件\n    if (isDefaultExitCover) return;\n\n    if (removeListenersEachExit && !manual) {\n      listListeners.removeListeners();\n    }\n  }\n};\n\nexport default focusNoJutsu;"],"names":["objToStr","obj","Object","prototype","toString","call","isObj","isFun","fun","getActiveElement","document","activeElement","element","e","str","querySelector","tick","fn","setTimeout","isEnterEvent","key","keyCode","isEscapeEvent","isTabEvent","isTabForward","shiftKey","isTabBackward","focus","node","tagName","toLowerCase","select","tickFocus","getKeyNodes","originRoot","originList","originCover","coverIsRoot","_element","list","map","item","filter","head","tail","slice","root","x","y","contains","range","Range","setStartBefore","setEndAfter","collapsed","commonAncestorContainer","findLowestCommonAncestorNode","cover","pickNodesAry","acc","cur","nodes","Array","isArray","n","_extends","concat","splitExits","exits","_exits$reduce","reduce","click","click_wild","focus_wild","outList","includeType","type","_e$type","includes","fill","keyExits","clickExits","focusExits","clickExits_wild","focusExits_wild","outListExits","hasClickExits","length","hasFocusExits","hasKeyExits","getExits","exit","onEscape","enabledCover","trigger","_tempExits$0$on","_tempExits$","tempExits","o","ele","undefined","t","_onEscape","on","target","delayToProcess","delay","processor","_ref","isFunctionDelay","delayRes","promiseDelay","then","callbackDelay","commonDelay","getDelayType","getTarget","activeIndex","defaultTarget","gotTarget","last","lastI","ListenersCache","this","cache","isEmpty","_proto","push","handler","clean","addListeners","forEach","l","_l$node","addEventListener","removeListeners","_l$node2","removeEventListener","KeyForwardCache","Map","_proto2","has","id","set","remove","_this","get","TabList","data","prevI","curI","_prev","_cur","_proto3","update","splice","apply","at","i","record","recordPrev","recordCur","prev","recordSequenceByIdx","v","_ref2","_entries$","offset","arguments","rootNode","subNodes","options","Error","sequence","loop","next","entry","onClick","onMove","initialActive","correctionTarget","delayToFocus","delayToBlur","_options$removeListen","removeListenersEachExit","removeListenersEachEnter","_options$addEntryList","addEntryListenersEachExit","manual","_options$allowSafariT","allowSafariToFocusAfterMousedown","entries","_entry$delay","onExit","hasNoEntry","toggles","Set","_trigger","_ref3","coverNode","coverEnterKey","enterKey","onEnterCover","onEnter","exitCover","exitsCover","_e$target","isDefaultExitCover","_ref4","isNext","onNext","_ref5","isPrev","onPrev","disabledEsc","isClamp","enabledTabSequence","trappedList","trappedCover","listListeners","entryListeners","keyForwards","addEntryListeners","some","_ref6","_getKeyNodes","newList","loadListRelatedListeners","Return","enter","entryHandler","fromInvoke","_loop","_entries$i","_ret","tempExit","_getKeyNodes2","originTarget","toExit","_loop2","_exits$i","_ret2","exitHandler","removeListRelatedListeners","removeEntryListeners","addListRelatedListeners","_getKeyNodes3","addForward","forward","opts","_getKeyNodes4","_opts","origin_node","origin_target","preventDefault","removeForward","updateList","_newList","newI","fromI","findNodesToLoadListenersAndFocus","_getKeyNodes5","listInfo","targetIdx","indexOf","focusTarget","Promise","resolve","_","listData","ef","_e$preventDefault","focusThenRemoveListeners","_delay","exitListWithTarget","_delay2","focusTriggerThenRemoveListeners","removeListenersWithoutFocus","exitListWithoutTarget","isTrappedList","keyListMoveHandler","useActiveIndex","_useActiveIndex","index_","setIndex","index","Math","max","itemsLen","incresedI","nextI","min","decresedI","focusNextListItemBySequence","bind","current","focusNextListItemByRange","_splitExits","clickListExitHandlers_wild","clickListExitHandler_wild","focusListExitHandlers_wild","focusListExitHandler_wild","isMouseDown","_correctionTarget","defaultLast","originGotCorrectionTarget","gotCorrectionTarget","targetIndex","findIndex","relatedTarget","active","isOutRootNode","isActiveCover","isOutList","outListExitHandler","isEnterFromCover","keyExitHandler","keyListExitHandler","prevBeforeRecord","prevIBeforeRecord","curIBeforeRecord","clickListItemHandler","clickExitHandler","clickListExitHandler","targetItem","find","window","safari","focusExitHandler","_ref7","_ref8","_exitsCover$i","origin","exitCoverHandler","_outListExits$i","exitHandlerWithCondition","condition","_loop3","types","allTypes","isKey","ifKey","processed","_getKeyNodes6","toggleEntryAndExit","toggleHandler"],"mappings":"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"}